// Code generated by protoc-gen-mcp. DO NOT EDIT.
// source: examples/complex/complex.proto

package complex_mcp

import (
	context "context"
	fmt "fmt"
	"reflect"
	"strings"

	mcp "github.com/mark3labs/mcp-go/mcp"
	server "github.com/mark3labs/mcp-go/server"
	complex1 "github.com/omrikiei/protoc-gen-mcp/examples/complex"
	"google.golang.org/protobuf/encoding/protojson"
)

// ComplexServiceServer is the MCP server API for ComplexService service.
type ComplexServiceServer interface {
	GetUserProfile(context.Context, *complex1.UserProfileRequest) (*complex1.UserProfileResponse, error)
	GetNestedResource(context.Context, *complex1.NestedRequest) (*complex1.NestedResponse, error)
	SearchResources(context.Context, *complex1.SearchRequest) (*complex1.SearchResponse, error)
	UploadResource(context.Context, *complex1.UploadRequest) (*complex1.Resource, error)
}

// ComplexServiceMCPServer implements the MCP server for ComplexService service.
type ComplexServiceMCPServer struct {
	server    ComplexServiceServer
	mcpServer *server.MCPServer
}

// NewComplexServiceMCPServer creates a new MCP server for ComplexService service.
func NewComplexServiceMCPServer(srv ComplexServiceServer) *ComplexServiceMCPServer {
	s := &ComplexServiceMCPServer{
		server: srv,
		mcpServer: server.NewMCPServer(
			"ComplexService",
			"v1",
		),
	}

	// Register resources for request and response messages
	// Register complex1.UserProfileRequest as resource
	s.mcpServer.AddResource(mcp.Resource{
		URI:         "complex1.UserProfileRequest",
		Name:        "complex1.UserProfileRequest",
		Description: "Request message for GetUserProfile method",
		MIMEType:    "application/json",
	}, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
		// Create a new instance of the request message
		req := &complex1.UserProfileRequest{}
		// Convert request parameters to message fields
		if err := convertParamsToMessage(request.Params.Arguments, req); err != nil {
			return nil, err
		}
		// Serialize the message to JSON
		jsonBytes, err := protojson.Marshal(req)
		if err != nil {
			return nil, fmt.Errorf("failed to serialize message: %v", err)
		}
		return []mcp.ResourceContents{mcp.TextResourceContents{
			Text: string(jsonBytes),
		}}, nil
	})

	// Register complex1.UserProfileResponse as resource
	s.mcpServer.AddResource(mcp.Resource{
		URI:         "complex1.UserProfileResponse",
		Name:        "complex1.UserProfileResponse",
		Description: "Response message for GetUserProfile method",
		MIMEType:    "application/json",
	}, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
		// Create a new instance of the response message
		resp := &complex1.UserProfileResponse{}
		// Convert request parameters to message fields
		if err := convertParamsToMessage(request.Params.Arguments, resp); err != nil {
			return nil, err
		}
		// Serialize the message to JSON
		jsonBytes, err := protojson.Marshal(resp)
		if err != nil {
			return nil, fmt.Errorf("failed to serialize message: %v", err)
		}
		return []mcp.ResourceContents{mcp.TextResourceContents{
			Text: string(jsonBytes),
		}}, nil
	})

	// Register complex1.NestedRequest as resource
	s.mcpServer.AddResource(mcp.Resource{
		URI:         "complex1.NestedRequest",
		Name:        "complex1.NestedRequest",
		Description: "Request message for GetNestedResource method",
		MIMEType:    "application/json",
	}, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
		// Create a new instance of the request message
		req := &complex1.NestedRequest{}
		// Convert request parameters to message fields
		if err := convertParamsToMessage(request.Params.Arguments, req); err != nil {
			return nil, err
		}
		// Serialize the message to JSON
		jsonBytes, err := protojson.Marshal(req)
		if err != nil {
			return nil, fmt.Errorf("failed to serialize message: %v", err)
		}
		return []mcp.ResourceContents{mcp.TextResourceContents{
			Text: string(jsonBytes),
		}}, nil
	})

	// Register complex1.NestedResponse as resource
	s.mcpServer.AddResource(mcp.Resource{
		URI:         "complex1.NestedResponse",
		Name:        "complex1.NestedResponse",
		Description: "Response message for GetNestedResource method",
		MIMEType:    "application/json",
	}, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
		// Create a new instance of the response message
		resp := &complex1.NestedResponse{}
		// Convert request parameters to message fields
		if err := convertParamsToMessage(request.Params.Arguments, resp); err != nil {
			return nil, err
		}
		// Serialize the message to JSON
		jsonBytes, err := protojson.Marshal(resp)
		if err != nil {
			return nil, fmt.Errorf("failed to serialize message: %v", err)
		}
		return []mcp.ResourceContents{mcp.TextResourceContents{
			Text: string(jsonBytes),
		}}, nil
	})

	// Register complex1.SearchRequest as resource
	s.mcpServer.AddResource(mcp.Resource{
		URI:         "complex1.SearchRequest",
		Name:        "complex1.SearchRequest",
		Description: "Request message for SearchResources method",
		MIMEType:    "application/json",
	}, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
		// Create a new instance of the request message
		req := &complex1.SearchRequest{}
		// Convert request parameters to message fields
		if err := convertParamsToMessage(request.Params.Arguments, req); err != nil {
			return nil, err
		}
		// Serialize the message to JSON
		jsonBytes, err := protojson.Marshal(req)
		if err != nil {
			return nil, fmt.Errorf("failed to serialize message: %v", err)
		}
		return []mcp.ResourceContents{mcp.TextResourceContents{
			Text: string(jsonBytes),
		}}, nil
	})

	// Register complex1.SearchResponse as resource
	s.mcpServer.AddResource(mcp.Resource{
		URI:         "complex1.SearchResponse",
		Name:        "complex1.SearchResponse",
		Description: "Response message for SearchResources method",
		MIMEType:    "application/json",
	}, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
		// Create a new instance of the response message
		resp := &complex1.SearchResponse{}
		// Convert request parameters to message fields
		if err := convertParamsToMessage(request.Params.Arguments, resp); err != nil {
			return nil, err
		}
		// Serialize the message to JSON
		jsonBytes, err := protojson.Marshal(resp)
		if err != nil {
			return nil, fmt.Errorf("failed to serialize message: %v", err)
		}
		return []mcp.ResourceContents{mcp.TextResourceContents{
			Text: string(jsonBytes),
		}}, nil
	})

	// Register complex1.UploadRequest as resource
	s.mcpServer.AddResource(mcp.Resource{
		URI:         "complex1.UploadRequest",
		Name:        "complex1.UploadRequest",
		Description: "Request message for UploadResource method",
		MIMEType:    "application/json",
	}, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
		// Create a new instance of the request message
		req := &complex1.UploadRequest{}
		// Convert request parameters to message fields
		if err := convertParamsToMessage(request.Params.Arguments, req); err != nil {
			return nil, err
		}
		// Serialize the message to JSON
		jsonBytes, err := protojson.Marshal(req)
		if err != nil {
			return nil, fmt.Errorf("failed to serialize message: %v", err)
		}
		return []mcp.ResourceContents{mcp.TextResourceContents{
			Text: string(jsonBytes),
		}}, nil
	})

	// Register complex1.Resource as resource
	s.mcpServer.AddResource(mcp.Resource{
		URI:         "complex1.Resource",
		Name:        "complex1.Resource",
		Description: "Response message for UploadResource method",
		MIMEType:    "application/json",
	}, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
		// Create a new instance of the response message
		resp := &complex1.Resource{}
		// Convert request parameters to message fields
		if err := convertParamsToMessage(request.Params.Arguments, resp); err != nil {
			return nil, err
		}
		// Serialize the message to JSON
		jsonBytes, err := protojson.Marshal(resp)
		if err != nil {
			return nil, fmt.Errorf("failed to serialize message: %v", err)
		}
		return []mcp.ResourceContents{mcp.TextResourceContents{
			Text: string(jsonBytes),
		}}, nil
	})

	// Register tools for each method
	// Create tool for GetUserProfile
	tool := mcp.NewTool("GetUserProfile",
		mcp.WithDescription("Retrieves a user's profile information"),
		mcp.WithToolAnnotation(mcp.ToolAnnotation{
			Title:           "Get User Profile",
			ReadOnlyHint:    true,
			DestructiveHint: false,
			IdempotentHint:  true,
			OpenWorldHint:   false,
		}),
		mcp.WithString("UserId",
			mcp.Pattern("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"),
		),
		mcp.WithString("ProfileId"),
		mcp.WithBoolean("IncludeDetails"),
		mcp.WithNumber("MaxDepth"),
	)

	// Add tool handler
	s.mcpServer.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		// Create input message
		req := &complex1.UserProfileRequest{}
		if val, ok := request.Params.Arguments["UserId"]; ok {
			if strVal, ok := val.(string); ok {
				req.UserId = strVal
			} else {
				return nil, fmt.Errorf("UserId must be a string")
			}
		}
		if val, ok := request.Params.Arguments["ProfileId"]; ok {
			if strVal, ok := val.(string); ok {
				req.ProfileId = strVal
			} else {
				return nil, fmt.Errorf("ProfileId must be a string")
			}
		}
		if val, ok := request.Params.Arguments["IncludeDetails"]; ok {
			if boolVal, ok := val.(bool); ok {
				req.IncludeDetails = boolVal
			} else {
				return nil, fmt.Errorf("IncludeDetails must be a boolean")
			}
		}
		if val, ok := request.Params.Arguments["MaxDepth"]; ok {
			if numVal, ok := val.(float64); ok {
				req.MaxDepth = int32(numVal)
			} else {
				return nil, fmt.Errorf("MaxDepth must be a number")
			}
		}

		// Call the service method
		resp, err := s.server.GetUserProfile(ctx, req)
		if err != nil {
			return nil, err
		}

		// Convert response to MCP result
		return mcp.NewToolResultText(fmt.Sprintf("%+v", resp)), nil
	})

	// Create tool for GetNestedResource
	tool = mcp.NewTool("GetNestedResource",
		mcp.WithDescription("Retrieves nested resource information"),
		mcp.WithToolAnnotation(mcp.ToolAnnotation{
			Title:           "Get Nested Resource",
			ReadOnlyHint:    true,
			DestructiveHint: false,
			IdempotentHint:  true,
			OpenWorldHint:   false,
		}),
		mcp.WithString("OrgId"),
		mcp.WithString("TeamId"),
		mcp.WithString("MemberId"),
		mcp.WithBoolean("Recursive"),
	)

	// Add tool handler
	s.mcpServer.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		// Create input message
		req := &complex1.NestedRequest{}
		if val, ok := request.Params.Arguments["OrgId"]; ok {
			if strVal, ok := val.(string); ok {
				req.OrgId = strVal
			} else {
				return nil, fmt.Errorf("OrgId must be a string")
			}
		}
		if val, ok := request.Params.Arguments["TeamId"]; ok {
			if strVal, ok := val.(string); ok {
				req.TeamId = strVal
			} else {
				return nil, fmt.Errorf("TeamId must be a string")
			}
		}
		if val, ok := request.Params.Arguments["MemberId"]; ok {
			if strVal, ok := val.(string); ok {
				req.MemberId = strVal
			} else {
				return nil, fmt.Errorf("MemberId must be a string")
			}
		}
		if val, ok := request.Params.Arguments["Recursive"]; ok {
			if boolVal, ok := val.(bool); ok {
				req.Recursive = boolVal
			} else {
				return nil, fmt.Errorf("Recursive must be a boolean")
			}
		}

		// Call the service method
		resp, err := s.server.GetNestedResource(ctx, req)
		if err != nil {
			return nil, err
		}

		// Convert response to MCP result
		return mcp.NewToolResultText(fmt.Sprintf("%+v", resp)), nil
	})

	// Create tool for SearchResources
	tool = mcp.NewTool("SearchResources",
		mcp.WithDescription("Searches for resources with complex filtering"),
		mcp.WithToolAnnotation(mcp.ToolAnnotation{
			Title:           "Search Resources",
			ReadOnlyHint:    true,
			DestructiveHint: false,
			IdempotentHint:  true,
			OpenWorldHint:   false,
		}),
		mcp.WithString("Query"),
		mcp.WithNumber("Page"),
		mcp.WithNumber("PageSize"),
		mcp.WithArray("Filters"),
		mcp.WithBoolean("IncludeDeleted"),
		mcp.WithString("SortBy"),
		mcp.WithBoolean("SortDesc"),
	)

	// Add tool handler
	s.mcpServer.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		// Create input message
		req := &complex1.SearchRequest{}
		if val, ok := request.Params.Arguments["Query"]; ok {
			if strVal, ok := val.(string); ok {
				req.Query = strVal
			} else {
				return nil, fmt.Errorf("Query must be a string")
			}
		}
		if val, ok := request.Params.Arguments["Page"]; ok {
			if numVal, ok := val.(float64); ok {
				req.Page = int32(numVal)
			} else {
				return nil, fmt.Errorf("Page must be a number")
			}
		}
		if val, ok := request.Params.Arguments["PageSize"]; ok {
			if numVal, ok := val.(float64); ok {
				req.PageSize = int32(numVal)
			} else {
				return nil, fmt.Errorf("PageSize must be a number")
			}
		}
		if val, ok := request.Params.Arguments["Filters"]; ok {
			if arrVal, ok := val.([]interface{}); ok {
				req.Filters = make([]string, len(arrVal))
				for i, v := range arrVal {
					if strVal, ok := v.(string); ok {
						req.Filters[i] = strVal
					} else {
						return nil, fmt.Errorf("Filters must be an array of strings")
					}
				}
			} else {
				return nil, fmt.Errorf("Filters must be an array of strings")
			}
		}
		if val, ok := request.Params.Arguments["IncludeDeleted"]; ok {
			if boolVal, ok := val.(bool); ok {
				req.IncludeDeleted = boolVal
			} else {
				return nil, fmt.Errorf("IncludeDeleted must be a boolean")
			}
		}
		if val, ok := request.Params.Arguments["SortBy"]; ok {
			if strVal, ok := val.(string); ok {
				req.SortBy = strVal
			} else {
				return nil, fmt.Errorf("SortBy must be a string")
			}
		}
		if val, ok := request.Params.Arguments["SortDesc"]; ok {
			if boolVal, ok := val.(bool); ok {
				req.SortDesc = boolVal
			} else {
				return nil, fmt.Errorf("SortDesc must be a boolean")
			}
		}

		// Call the service method
		resp, err := s.server.SearchResources(ctx, req)
		if err != nil {
			return nil, err
		}

		// Convert response to MCP result
		return mcp.NewToolResultText(fmt.Sprintf("%+v", resp)), nil
	})

	// Create tool for UploadResource
	tool = mcp.NewTool("UploadResource",
		mcp.WithDescription("Uploads a new resource with binary content"),
		mcp.WithToolAnnotation(mcp.ToolAnnotation{
			Title:           "Upload Resource",
			ReadOnlyHint:    false,
			DestructiveHint: true,
			IdempotentHint:  false,
			OpenWorldHint:   true,
		}),
		mcp.WithString("Name",
			mcp.Pattern("^[a-zA-Z0-9_-]{1,100}$"),
		),
		mcp.WithString("Type"),
		mcp.WithObject("Metadata"),
		mcp.WithString("Content"),
	)

	// Add tool handler
	s.mcpServer.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		// Create input message
		req := &complex1.UploadRequest{}
		if val, ok := request.Params.Arguments["Name"]; ok {
			if strVal, ok := val.(string); ok {
				req.Name = strVal
			} else {
				return nil, fmt.Errorf("Name must be a string")
			}
		}
		if val, ok := request.Params.Arguments["Type"]; ok {
			if strVal, ok := val.(string); ok {
				req.Type = strVal
			} else {
				return nil, fmt.Errorf("Type must be a string")
			}
		}
		if val, ok := request.Params.Arguments["Metadata"]; ok {
			if mapVal, ok := val.(map[string]interface{}); ok {
				req.Metadata = make(map[string]string)
				for k, v := range mapVal {
					if strVal, ok := v.(string); ok {
						req.Metadata[k] = strVal
					} else {
						return nil, fmt.Errorf("map value must be a string")
					}
				}
			} else {
				return nil, fmt.Errorf("Metadata must be a map")
			}
		}
		if val, ok := request.Params.Arguments["Content"]; ok {
			if strVal, ok := val.(string); ok {
				req.Content = []byte(strVal)
			} else {
				return nil, fmt.Errorf("Content must be a string")
			}
		}

		// Call the service method
		resp, err := s.server.UploadResource(ctx, req)
		if err != nil {
			return nil, err
		}

		// Convert response to MCP result
		return mcp.NewToolResultText(fmt.Sprintf("%+v", resp)), nil
	})

	return s
}

// Start starts the MCP server
func (s *ComplexServiceMCPServer) Start() error {
	return server.ServeStdio(s.mcpServer)
}

// convertParamsToMessage converts MCP parameters to message fields
func convertParamsToMessage(params map[string]interface{}, msg interface{}) error {
	// Use reflection to set message fields
	val := reflect.ValueOf(msg).Elem()
	typ := val.Type()

	for i := 0; i < val.NumField(); i++ {
		field := val.Field(i)
		fieldType := typ.Field(i)

		// Get field name from protobuf tag
		tag := fieldType.Tag.Get("protobuf")
		if tag == "" {
			continue
		}

		// Extract field name from protobuf tag
		parts := strings.Split(tag, ",")
		if len(parts) < 3 {
			continue
		}
		fieldName := parts[2]

		// Get value from params
		paramVal, ok := params[fieldName]
		if !ok {
			continue
		}

		// Convert and set field value based on type
		switch field.Kind() {
		case reflect.String:
			if strVal, ok := paramVal.(string); ok {
				field.SetString(strVal)
			}
		case reflect.Int32, reflect.Int64:
			if numVal, ok := paramVal.(float64); ok {
				field.SetInt(int64(numVal))
			}
		case reflect.Uint32, reflect.Uint64:
			if numVal, ok := paramVal.(float64); ok {
				field.SetUint(uint64(numVal))
			}
		case reflect.Bool:
			if boolVal, ok := paramVal.(bool); ok {
				field.SetBool(boolVal)
			}
		case reflect.Slice:
			if arrVal, ok := paramVal.([]interface{}); ok {
				slice := reflect.MakeSlice(field.Type(), len(arrVal), len(arrVal))
				for j, v := range arrVal {
					switch field.Type().Elem().Kind() {
					case reflect.String:
						if strVal, ok := v.(string); ok {
							slice.Index(j).SetString(strVal)
						}
					case reflect.Int32, reflect.Int64:
						if numVal, ok := v.(float64); ok {
							slice.Index(j).SetInt(int64(numVal))
						}
					case reflect.Uint32, reflect.Uint64:
						if numVal, ok := v.(float64); ok {
							slice.Index(j).SetUint(uint64(numVal))
						}
					case reflect.Bool:
						if boolVal, ok := v.(bool); ok {
							slice.Index(j).SetBool(boolVal)
						}
					}
				}
				field.Set(slice)
			}
		}
	}

	return nil
}
