// Code generated by protoc-gen-mcp. DO NOT EDIT.
// source: examples/complex/complex.proto

package complex_mcp

import (
	context "context"
	fmt "fmt"
	mcp "github.com/mark3labs/mcp-go/mcp"
	server "github.com/mark3labs/mcp-go/server"
	complex1 "github.com/omrikiei/protoc-gen-mcp/examples/complex"
)

// ComplexServiceServer is the MCP server API for ComplexService service.
type ComplexServiceServer interface {
	GetUserProfile(context.Context, *complex1.UserProfileRequest) (*complex1.UserProfileResponse, error)
	GetNestedResource(context.Context, *complex1.NestedRequest) (*complex1.NestedResponse, error)
	SearchResources(context.Context, *complex1.SearchRequest) (*complex1.SearchResponse, error)
	UploadResource(context.Context, *complex1.UploadRequest) (*complex1.Resource, error)
}

// ComplexServiceMCPServer implements the MCP server for ComplexService service.
type ComplexServiceMCPServer struct {
	server    ComplexServiceServer
	mcpServer *server.MCPServer
}

// NewComplexServiceMCPServer creates a new MCP server for ComplexService service.
func NewComplexServiceMCPServer(srv ComplexServiceServer) *ComplexServiceMCPServer {
	s := &ComplexServiceMCPServer{
		server: srv,
		mcpServer: server.NewMCPServer(
			"ComplexService",
			"v1",
		),
	}

	// Register tools for each method
	// Create tool for GetUserProfile
	tool := mcp.NewTool("GetUserProfile",
		mcp.WithDescription("Retrieves a user's profile information"),
		mcp.WithToolAnnotation(mcp.ToolAnnotation{
			Title:           "Get User Profile",
			ReadOnlyHint:    true,
			DestructiveHint: false,
			IdempotentHint:  true,
			OpenWorldHint:   false,
		}),
		mcp.WithString("UserId",
			mcp.Pattern("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$"),
		),
		mcp.WithString("ProfileId"),
		mcp.WithBoolean("IncludeDetails"),
		mcp.WithNumber("MaxDepth"),
	)

	// Add tool handler
	s.mcpServer.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		// Create input message
		req := &complex1.UserProfileRequest{}
		if val, ok := request.Params.Arguments["UserId"]; ok {
			if strVal, ok := val.(string); ok {
				req.UserId = strVal
			} else {
				return nil, fmt.Errorf("UserId must be a string")
			}
		}
		if val, ok := request.Params.Arguments["ProfileId"]; ok {
			if strVal, ok := val.(string); ok {
				req.ProfileId = strVal
			} else {
				return nil, fmt.Errorf("ProfileId must be a string")
			}
		}
		if val, ok := request.Params.Arguments["IncludeDetails"]; ok {
			if boolVal, ok := val.(bool); ok {
				req.IncludeDetails = boolVal
			} else {
				return nil, fmt.Errorf("IncludeDetails must be a boolean")
			}
		}
		if val, ok := request.Params.Arguments["MaxDepth"]; ok {
			if numVal, ok := val.(float64); ok {
				req.MaxDepth = int32(numVal)
			} else {
				return nil, fmt.Errorf("MaxDepth must be a number")
			}
		}

		// Call the service method
		resp, err := s.server.GetUserProfile(ctx, req)
		if err != nil {
			return nil, err
		}

		// Convert response to MCP result
		return mcp.NewToolResultText(fmt.Sprintf("%+v", resp)), nil
	})

	// Create tool for GetNestedResource
	tool = mcp.NewTool("GetNestedResource",
		mcp.WithDescription("Retrieves nested resource information"),
		mcp.WithToolAnnotation(mcp.ToolAnnotation{
			Title:           "Get Nested Resource",
			ReadOnlyHint:    true,
			DestructiveHint: false,
			IdempotentHint:  true,
			OpenWorldHint:   false,
		}),
		mcp.WithString("OrgId"),
		mcp.WithString("TeamId"),
		mcp.WithString("MemberId"),
		mcp.WithBoolean("Recursive"),
	)

	// Add tool handler
	s.mcpServer.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		// Create input message
		req := &complex1.NestedRequest{}
		if val, ok := request.Params.Arguments["OrgId"]; ok {
			if strVal, ok := val.(string); ok {
				req.OrgId = strVal
			} else {
				return nil, fmt.Errorf("OrgId must be a string")
			}
		}
		if val, ok := request.Params.Arguments["TeamId"]; ok {
			if strVal, ok := val.(string); ok {
				req.TeamId = strVal
			} else {
				return nil, fmt.Errorf("TeamId must be a string")
			}
		}
		if val, ok := request.Params.Arguments["MemberId"]; ok {
			if strVal, ok := val.(string); ok {
				req.MemberId = strVal
			} else {
				return nil, fmt.Errorf("MemberId must be a string")
			}
		}
		if val, ok := request.Params.Arguments["Recursive"]; ok {
			if boolVal, ok := val.(bool); ok {
				req.Recursive = boolVal
			} else {
				return nil, fmt.Errorf("Recursive must be a boolean")
			}
		}

		// Call the service method
		resp, err := s.server.GetNestedResource(ctx, req)
		if err != nil {
			return nil, err
		}

		// Convert response to MCP result
		return mcp.NewToolResultText(fmt.Sprintf("%+v", resp)), nil
	})

	// Create tool for SearchResources
	tool = mcp.NewTool("SearchResources",
		mcp.WithDescription("Searches for resources with complex filtering"),
		mcp.WithToolAnnotation(mcp.ToolAnnotation{
			Title:           "Search Resources",
			ReadOnlyHint:    true,
			DestructiveHint: false,
			IdempotentHint:  true,
			OpenWorldHint:   false,
		}),
		mcp.WithString("Query"),
		mcp.WithNumber("Page"),
		mcp.WithNumber("PageSize"),
		mcp.WithArray("Filters"),
		mcp.WithBoolean("IncludeDeleted"),
		mcp.WithString("SortBy"),
		mcp.WithBoolean("SortDesc"),
	)

	// Add tool handler
	s.mcpServer.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		// Create input message
		req := &complex1.SearchRequest{}
		if val, ok := request.Params.Arguments["Query"]; ok {
			if strVal, ok := val.(string); ok {
				req.Query = strVal
			} else {
				return nil, fmt.Errorf("Query must be a string")
			}
		}
		if val, ok := request.Params.Arguments["Page"]; ok {
			if numVal, ok := val.(float64); ok {
				req.Page = int32(numVal)
			} else {
				return nil, fmt.Errorf("Page must be a number")
			}
		}
		if val, ok := request.Params.Arguments["PageSize"]; ok {
			if numVal, ok := val.(float64); ok {
				req.PageSize = int32(numVal)
			} else {
				return nil, fmt.Errorf("PageSize must be a number")
			}
		}
		if val, ok := request.Params.Arguments["Filters"]; ok {
			if arrVal, ok := val.([]interface{}); ok {
				req.Filters = make([]string, len(arrVal))
				for i, v := range arrVal {
					if strVal, ok := v.(string); ok {
						req.Filters[i] = strVal
					} else {
						return nil, fmt.Errorf("Filters must be an array of strings")
					}
				}
			} else {
				return nil, fmt.Errorf("Filters must be an array of strings")
			}
		}
		if val, ok := request.Params.Arguments["IncludeDeleted"]; ok {
			if boolVal, ok := val.(bool); ok {
				req.IncludeDeleted = boolVal
			} else {
				return nil, fmt.Errorf("IncludeDeleted must be a boolean")
			}
		}
		if val, ok := request.Params.Arguments["SortBy"]; ok {
			if strVal, ok := val.(string); ok {
				req.SortBy = strVal
			} else {
				return nil, fmt.Errorf("SortBy must be a string")
			}
		}
		if val, ok := request.Params.Arguments["SortDesc"]; ok {
			if boolVal, ok := val.(bool); ok {
				req.SortDesc = boolVal
			} else {
				return nil, fmt.Errorf("SortDesc must be a boolean")
			}
		}

		// Call the service method
		resp, err := s.server.SearchResources(ctx, req)
		if err != nil {
			return nil, err
		}

		// Convert response to MCP result
		return mcp.NewToolResultText(fmt.Sprintf("%+v", resp)), nil
	})

	// Create tool for UploadResource
	tool = mcp.NewTool("UploadResource",
		mcp.WithDescription("Uploads a new resource with binary content"),
		mcp.WithToolAnnotation(mcp.ToolAnnotation{
			Title:           "Upload Resource",
			ReadOnlyHint:    false,
			DestructiveHint: true,
			IdempotentHint:  false,
			OpenWorldHint:   true,
		}),
		mcp.WithString("Name",
			mcp.Pattern("^[a-zA-Z0-9_-]{1,100}$"),
		),
		mcp.WithString("Type"),
		mcp.WithObject("Metadata"),
		mcp.WithString("Content"),
	)

	// Add tool handler
	s.mcpServer.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		// Create input message
		req := &complex1.UploadRequest{}
		if val, ok := request.Params.Arguments["Name"]; ok {
			if strVal, ok := val.(string); ok {
				req.Name = strVal
			} else {
				return nil, fmt.Errorf("Name must be a string")
			}
		}
		if val, ok := request.Params.Arguments["Type"]; ok {
			if strVal, ok := val.(string); ok {
				req.Type = strVal
			} else {
				return nil, fmt.Errorf("Type must be a string")
			}
		}
		if val, ok := request.Params.Arguments["Metadata"]; ok {
			if mapVal, ok := val.(map[string]interface{}); ok {
				req.Metadata = make(map[string]string)
				for k, v := range mapVal {
					if strVal, ok := v.(string); ok {
						req.Metadata[k] = strVal
					} else {
						return nil, fmt.Errorf("map value must be a string")
					}
				}
			} else {
				return nil, fmt.Errorf("Metadata must be a map")
			}
		}
		if val, ok := request.Params.Arguments["Content"]; ok {
			if strVal, ok := val.(string); ok {
				req.Content = []byte(strVal)
			} else {
				return nil, fmt.Errorf("Content must be a string")
			}
		}

		// Call the service method
		resp, err := s.server.UploadResource(ctx, req)
		if err != nil {
			return nil, err
		}

		// Convert response to MCP result
		return mcp.NewToolResultText(fmt.Sprintf("%+v", resp)), nil
	})

	return s
}

// Start starts the MCP server
func (s *ComplexServiceMCPServer) Start() error {
	return server.ServeStdio(s.mcpServer)
}
