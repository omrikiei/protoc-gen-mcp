// Code generated by protoc-gen-mcp. DO NOT EDIT.
// source: examples/helloworld/helloworld.proto

package helloworld

import (
	context "context"
	fmt "fmt"
	mcp "github.com/mark3labs/mcp-go/mcp"
	server "github.com/mark3labs/mcp-go/server"
	protojson "google.golang.org/protobuf/encoding/protojson"
	reflect "reflect"
	strings "strings"
)

// GreeterMCPServer is the MCP server API for Greeter service.
type GreeterMCPServer interface {
	SayHello(context.Context, *HelloRequest) (*HelloReply, error)
	SayHelloWithQuery(context.Context, *HelloRequest) (*HelloReply, error)
	StreamGreetings(context.Context, *HelloRequest) (*HelloReply, error)
}

// GreeterMCPServerImpl implements the MCP server for Greeter service.
type GreeterMCPServerImpl struct {
	server    GreeterMCPServer
	mcpServer *server.MCPServer
}

// NewGreeterMCPServer creates a new MCP server for Greeter service.
func NewGreeterMCPServer(srv GreeterMCPServer) *GreeterMCPServerImpl {
	s := &GreeterMCPServerImpl{
		server: srv,
		mcpServer: server.NewMCPServer(
			"Greeter",
			"v1",
		),
	}

	// Register resources for request and response messages
	// Register HelloRequest as resource
	s.mcpServer.AddResource(mcp.Resource{
		URI:         "HelloRequest",
		Name:        "HelloRequest",
		Description: "Request message for SayHello method",
		MIMEType:    "application/json",
	}, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
		// Create a new instance of the request message
		req := &HelloRequest{}
		// Convert request parameters to message fields
		if err := convertParamsToMessage(request.Params.Arguments, req); err != nil {
			return nil, err
		}
		// Serialize the message to JSON
		jsonBytes, err := protojson.Marshal(req)
		if err != nil {
			return nil, fmt.Errorf("failed to serialize message: %v", err)
		}
		return []mcp.ResourceContents{mcp.TextResourceContents{
			Text: string(jsonBytes),
		}}, nil
	})

	// Register HelloReply as resource
	s.mcpServer.AddResource(mcp.Resource{
		URI:         "HelloReply",
		Name:        "HelloReply",
		Description: "Response message for SayHello method",
		MIMEType:    "application/json",
	}, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
		// Create a new instance of the response message
		resp := &HelloReply{}
		// Convert request parameters to message fields
		if err := convertParamsToMessage(request.Params.Arguments, resp); err != nil {
			return nil, err
		}
		// Serialize the message to JSON
		jsonBytes, err := protojson.Marshal(resp)
		if err != nil {
			return nil, fmt.Errorf("failed to serialize message: %v", err)
		}
		return []mcp.ResourceContents{mcp.TextResourceContents{
			Text: string(jsonBytes),
		}}, nil
	})

	// Register HelloRequest as resource
	s.mcpServer.AddResource(mcp.Resource{
		URI:         "HelloRequest",
		Name:        "HelloRequest",
		Description: "Request message for SayHelloWithQuery method",
		MIMEType:    "application/json",
	}, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
		// Create a new instance of the request message
		req := &HelloRequest{}
		// Convert request parameters to message fields
		if err := convertParamsToMessage(request.Params.Arguments, req); err != nil {
			return nil, err
		}
		// Serialize the message to JSON
		jsonBytes, err := protojson.Marshal(req)
		if err != nil {
			return nil, fmt.Errorf("failed to serialize message: %v", err)
		}
		return []mcp.ResourceContents{mcp.TextResourceContents{
			Text: string(jsonBytes),
		}}, nil
	})

	// Register HelloReply as resource
	s.mcpServer.AddResource(mcp.Resource{
		URI:         "HelloReply",
		Name:        "HelloReply",
		Description: "Response message for SayHelloWithQuery method",
		MIMEType:    "application/json",
	}, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
		// Create a new instance of the response message
		resp := &HelloReply{}
		// Convert request parameters to message fields
		if err := convertParamsToMessage(request.Params.Arguments, resp); err != nil {
			return nil, err
		}
		// Serialize the message to JSON
		jsonBytes, err := protojson.Marshal(resp)
		if err != nil {
			return nil, fmt.Errorf("failed to serialize message: %v", err)
		}
		return []mcp.ResourceContents{mcp.TextResourceContents{
			Text: string(jsonBytes),
		}}, nil
	})

	// Register HelloRequest as resource
	s.mcpServer.AddResource(mcp.Resource{
		URI:         "HelloRequest",
		Name:        "HelloRequest",
		Description: "Request message for StreamGreetings method",
		MIMEType:    "application/json",
	}, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
		// Create a new instance of the request message
		req := &HelloRequest{}
		// Convert request parameters to message fields
		if err := convertParamsToMessage(request.Params.Arguments, req); err != nil {
			return nil, err
		}
		// Serialize the message to JSON
		jsonBytes, err := protojson.Marshal(req)
		if err != nil {
			return nil, fmt.Errorf("failed to serialize message: %v", err)
		}
		return []mcp.ResourceContents{mcp.TextResourceContents{
			Text: string(jsonBytes),
		}}, nil
	})

	// Register HelloReply as resource
	s.mcpServer.AddResource(mcp.Resource{
		URI:         "HelloReply",
		Name:        "HelloReply",
		Description: "Response message for StreamGreetings method",
		MIMEType:    "application/json",
	}, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {
		// Create a new instance of the response message
		resp := &HelloReply{}
		// Convert request parameters to message fields
		if err := convertParamsToMessage(request.Params.Arguments, resp); err != nil {
			return nil, err
		}
		// Serialize the message to JSON
		jsonBytes, err := protojson.Marshal(resp)
		if err != nil {
			return nil, fmt.Errorf("failed to serialize message: %v", err)
		}
		return []mcp.ResourceContents{mcp.TextResourceContents{
			Text: string(jsonBytes),
		}}, nil
	})

	// Register tools for each method
	// Create tool for SayHello
	tool := mcp.NewTool("SayHello",
		mcp.WithDescription("Sends a simple greeting to the user"),
		mcp.WithToolAnnotation(mcp.ToolAnnotation{
			Title:           "Say Hello",
			ReadOnlyHint:    true,
			DestructiveHint: false,
			IdempotentHint:  true,
			OpenWorldHint:   false,
		}),
		mcp.WithString("Name",
			mcp.Pattern("^[a-zA-Z0-9_]{3,50}$"),
		),
		mcp.WithString("Language",
			mcp.Pattern("^(en|es|fr|de)$"),
		),
		mcp.WithBoolean("Formal"),
		mcp.WithNumber("Repeat"),
	)

	// Add tool handler
	s.mcpServer.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		// Create input message
		req := &HelloRequest{}
		if val, ok := request.Params.Arguments["Name"]; ok {
			if strVal, ok := val.(string); ok {
				req.Name = strVal
			} else {
				return nil, fmt.Errorf("Name must be a string")
			}
		}
		if val, ok := request.Params.Arguments["Language"]; ok {
			if strVal, ok := val.(string); ok {
				req.Language = strVal
			} else {
				return nil, fmt.Errorf("Language must be a string")
			}
		}
		if val, ok := request.Params.Arguments["Formal"]; ok {
			if boolVal, ok := val.(bool); ok {
				req.Formal = boolVal
			} else {
				return nil, fmt.Errorf("Formal must be a boolean")
			}
		}
		if val, ok := request.Params.Arguments["Repeat"]; ok {
			if numVal, ok := val.(float64); ok {
				req.Repeat = int32(numVal)
			} else {
				return nil, fmt.Errorf("Repeat must be a number")
			}
		}

		// Call the service method
		resp, err := s.server.SayHello(ctx, req)
		if err != nil {
			return nil, err
		}

		// Convert response to MCP result
		return mcp.NewToolResultText(fmt.Sprintf("%+v", resp)), nil
	})

	// Create tool for SayHelloWithQuery
	tool = mcp.NewTool("SayHelloWithQuery",
		mcp.WithDescription("Sends a greeting with additional query parameters"),
		mcp.WithToolAnnotation(mcp.ToolAnnotation{
			Title:           "Say Hello with Query",
			ReadOnlyHint:    true,
			DestructiveHint: false,
			IdempotentHint:  true,
			OpenWorldHint:   false,
		}),
		mcp.WithString("Name",
			mcp.Pattern("^[a-zA-Z0-9_]{3,50}$"),
		),
		mcp.WithString("Language",
			mcp.Pattern("^(en|es|fr|de)$"),
		),
		mcp.WithBoolean("Formal"),
		mcp.WithNumber("Repeat"),
	)

	// Add tool handler
	s.mcpServer.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		// Create input message
		req := &HelloRequest{}
		if val, ok := request.Params.Arguments["Name"]; ok {
			if strVal, ok := val.(string); ok {
				req.Name = strVal
			} else {
				return nil, fmt.Errorf("Name must be a string")
			}
		}
		if val, ok := request.Params.Arguments["Language"]; ok {
			if strVal, ok := val.(string); ok {
				req.Language = strVal
			} else {
				return nil, fmt.Errorf("Language must be a string")
			}
		}
		if val, ok := request.Params.Arguments["Formal"]; ok {
			if boolVal, ok := val.(bool); ok {
				req.Formal = boolVal
			} else {
				return nil, fmt.Errorf("Formal must be a boolean")
			}
		}
		if val, ok := request.Params.Arguments["Repeat"]; ok {
			if numVal, ok := val.(float64); ok {
				req.Repeat = int32(numVal)
			} else {
				return nil, fmt.Errorf("Repeat must be a number")
			}
		}

		// Call the service method
		resp, err := s.server.SayHelloWithQuery(ctx, req)
		if err != nil {
			return nil, err
		}

		// Convert response to MCP result
		return mcp.NewToolResultText(fmt.Sprintf("%+v", resp)), nil
	})

	// Create tool for StreamGreetings
	tool = mcp.NewTool("StreamGreetings",
		mcp.WithDescription("Streams multiple greetings to the user"),
		mcp.WithToolAnnotation(mcp.ToolAnnotation{
			Title:           "Stream Greetings",
			ReadOnlyHint:    true,
			DestructiveHint: false,
			IdempotentHint:  true,
			OpenWorldHint:   false,
		}),
		mcp.WithString("Name",
			mcp.Pattern("^[a-zA-Z0-9_]{3,50}$"),
		),
		mcp.WithString("Language",
			mcp.Pattern("^(en|es|fr|de)$"),
		),
		mcp.WithBoolean("Formal"),
		mcp.WithNumber("Repeat"),
	)

	// Add tool handler
	s.mcpServer.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		// Create input message
		req := &HelloRequest{}
		if val, ok := request.Params.Arguments["Name"]; ok {
			if strVal, ok := val.(string); ok {
				req.Name = strVal
			} else {
				return nil, fmt.Errorf("Name must be a string")
			}
		}
		if val, ok := request.Params.Arguments["Language"]; ok {
			if strVal, ok := val.(string); ok {
				req.Language = strVal
			} else {
				return nil, fmt.Errorf("Language must be a string")
			}
		}
		if val, ok := request.Params.Arguments["Formal"]; ok {
			if boolVal, ok := val.(bool); ok {
				req.Formal = boolVal
			} else {
				return nil, fmt.Errorf("Formal must be a boolean")
			}
		}
		if val, ok := request.Params.Arguments["Repeat"]; ok {
			if numVal, ok := val.(float64); ok {
				req.Repeat = int32(numVal)
			} else {
				return nil, fmt.Errorf("Repeat must be a number")
			}
		}

		// Call the service method
		resp, err := s.server.StreamGreetings(ctx, req)
		if err != nil {
			return nil, err
		}

		// Convert response to MCP result
		return mcp.NewToolResultText(fmt.Sprintf("%+v", resp)), nil
	})

	return s
}

// Start starts the MCP server
func (s *GreeterMCPServerImpl) Start() error {
	return server.ServeStdio(s.mcpServer)
}

// convertParamsToMessage converts MCP parameters to message fields
func convertParamsToMessage(params map[string]interface{}, msg interface{}) error {
	// Use reflection to set message fields
	val := reflect.ValueOf(msg).Elem()
	typ := val.Type()

	for i := 0; i < val.NumField(); i++ {
		field := val.Field(i)
		fieldType := typ.Field(i)

		// Get field name from protobuf tag
		tag := fieldType.Tag.Get("protobuf")
		if tag == "" {
			continue
		}

		// Extract field name from protobuf tag
		parts := strings.Split(tag, ",")
		if len(parts) < 3 {
			continue
		}
		fieldName := parts[2]

		// Get value from params
		paramVal, ok := params[fieldName]
		if !ok {
			continue
		}

		// Convert and set field value based on type
		switch field.Kind() {
		case reflect.String:
			if strVal, ok := paramVal.(string); ok {
				field.SetString(strVal)
			}
		case reflect.Int32, reflect.Int64:
			if numVal, ok := paramVal.(float64); ok {
				field.SetInt(int64(numVal))
			}
		case reflect.Uint32, reflect.Uint64:
			if numVal, ok := paramVal.(float64); ok {
				field.SetUint(uint64(numVal))
			}
		case reflect.Bool:
			if boolVal, ok := paramVal.(bool); ok {
				field.SetBool(boolVal)
			}
		case reflect.Slice:
			if arrVal, ok := paramVal.([]interface{}); ok {
				slice := reflect.MakeSlice(field.Type(), len(arrVal), len(arrVal))
				for j, v := range arrVal {
					switch field.Type().Elem().Kind() {
					case reflect.String:
						if strVal, ok := v.(string); ok {
							slice.Index(j).SetString(strVal)
						}
					case reflect.Int32, reflect.Int64:
						if numVal, ok := v.(float64); ok {
							slice.Index(j).SetInt(int64(numVal))
						}
					case reflect.Uint32, reflect.Uint64:
						if numVal, ok := v.(float64); ok {
							slice.Index(j).SetUint(uint64(numVal))
						}
					case reflect.Bool:
						if boolVal, ok := v.(bool); ok {
							slice.Index(j).SetBool(boolVal)
						}
					}
				}
				field.Set(slice)
			}
		}
	}

	return nil
}
