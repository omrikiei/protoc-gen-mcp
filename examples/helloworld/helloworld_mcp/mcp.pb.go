// Code generated by protoc-gen-mcp. DO NOT EDIT.
// source: examples/helloworld/helloworld.proto

package helloworld_mcp

import (
	context "context"
	fmt "fmt"
	mcp "github.com/mark3labs/mcp-go/mcp"
	server "github.com/mark3labs/mcp-go/server"
	helloworld "github.com/omrikiei/protoc-gen-mcp/examples/helloworld"
)

// GreeterServer is the MCP server API for Greeter service.
type GreeterServer interface {
	SayHello(context.Context, *helloworld.HelloRequest) (*helloworld.HelloReply, error)
	SayHelloWithQuery(context.Context, *helloworld.HelloRequest) (*helloworld.HelloReply, error)
	StreamGreetings(context.Context, *helloworld.HelloRequest) (*helloworld.HelloReply, error)
}

// GreeterMCPServer implements the MCP server for Greeter service.
type GreeterMCPServer struct {
	server    GreeterServer
	mcpServer *server.MCPServer
}

// NewGreeterMCPServer creates a new MCP server for Greeter service.
func NewGreeterMCPServer(srv GreeterServer) *GreeterMCPServer {
	s := &GreeterMCPServer{
		server: srv,
		mcpServer: server.NewMCPServer(
			"Greeter",
			"v1",
		),
	}

	// Register tools for each method
	// Create tool for SayHello
	tool := mcp.NewTool("SayHello",
		mcp.WithDescription("Sends a simple greeting to the user"),
		mcp.WithToolAnnotation(mcp.ToolAnnotation{
			Title:           "Say Hello",
			ReadOnlyHint:    true,
			DestructiveHint: false,
			IdempotentHint:  true,
			OpenWorldHint:   false,
		}),
		mcp.WithString("Name",
			mcp.Pattern("^[a-zA-Z0-9_]{3,50}$"),
		),
		mcp.WithString("Language",
			mcp.Pattern("^(en|es|fr|de)$"),
		),
		mcp.WithBoolean("Formal"),
		mcp.WithNumber("Repeat"),
	)

	// Add tool handler
	s.mcpServer.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		// Create input message
		req := &helloworld.HelloRequest{}
		if val, ok := request.Params.Arguments["Name"]; ok {
			if strVal, ok := val.(string); ok {
				req.Name = strVal
			} else {
				return nil, fmt.Errorf("Name must be a string")
			}
		}
		if val, ok := request.Params.Arguments["Language"]; ok {
			if strVal, ok := val.(string); ok {
				req.Language = strVal
			} else {
				return nil, fmt.Errorf("Language must be a string")
			}
		}
		if val, ok := request.Params.Arguments["Formal"]; ok {
			if boolVal, ok := val.(bool); ok {
				req.Formal = boolVal
			} else {
				return nil, fmt.Errorf("Formal must be a boolean")
			}
		}
		if val, ok := request.Params.Arguments["Repeat"]; ok {
			if numVal, ok := val.(float64); ok {
				req.Repeat = int32(numVal)
			} else {
				return nil, fmt.Errorf("Repeat must be a number")
			}
		}

		// Call the service method
		resp, err := s.server.SayHello(ctx, req)
		if err != nil {
			return nil, err
		}

		// Convert response to MCP result
		return mcp.NewToolResultText(fmt.Sprintf("%+v", resp)), nil
	})

	// Create tool for SayHelloWithQuery
	tool = mcp.NewTool("SayHelloWithQuery",
		mcp.WithDescription("Sends a greeting with additional query parameters"),
		mcp.WithToolAnnotation(mcp.ToolAnnotation{
			Title:           "Say Hello with Query",
			ReadOnlyHint:    true,
			DestructiveHint: false,
			IdempotentHint:  true,
			OpenWorldHint:   false,
		}),
		mcp.WithString("Name",
			mcp.Pattern("^[a-zA-Z0-9_]{3,50}$"),
		),
		mcp.WithString("Language",
			mcp.Pattern("^(en|es|fr|de)$"),
		),
		mcp.WithBoolean("Formal"),
		mcp.WithNumber("Repeat"),
	)

	// Add tool handler
	s.mcpServer.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		// Create input message
		req := &helloworld.HelloRequest{}
		if val, ok := request.Params.Arguments["Name"]; ok {
			if strVal, ok := val.(string); ok {
				req.Name = strVal
			} else {
				return nil, fmt.Errorf("Name must be a string")
			}
		}
		if val, ok := request.Params.Arguments["Language"]; ok {
			if strVal, ok := val.(string); ok {
				req.Language = strVal
			} else {
				return nil, fmt.Errorf("Language must be a string")
			}
		}
		if val, ok := request.Params.Arguments["Formal"]; ok {
			if boolVal, ok := val.(bool); ok {
				req.Formal = boolVal
			} else {
				return nil, fmt.Errorf("Formal must be a boolean")
			}
		}
		if val, ok := request.Params.Arguments["Repeat"]; ok {
			if numVal, ok := val.(float64); ok {
				req.Repeat = int32(numVal)
			} else {
				return nil, fmt.Errorf("Repeat must be a number")
			}
		}

		// Call the service method
		resp, err := s.server.SayHelloWithQuery(ctx, req)
		if err != nil {
			return nil, err
		}

		// Convert response to MCP result
		return mcp.NewToolResultText(fmt.Sprintf("%+v", resp)), nil
	})

	// Create tool for StreamGreetings
	tool = mcp.NewTool("StreamGreetings",
		mcp.WithDescription("Streams multiple greetings to the user"),
		mcp.WithToolAnnotation(mcp.ToolAnnotation{
			Title:           "Stream Greetings",
			ReadOnlyHint:    true,
			DestructiveHint: false,
			IdempotentHint:  true,
			OpenWorldHint:   false,
		}),
		mcp.WithString("Name",
			mcp.Pattern("^[a-zA-Z0-9_]{3,50}$"),
		),
		mcp.WithString("Language",
			mcp.Pattern("^(en|es|fr|de)$"),
		),
		mcp.WithBoolean("Formal"),
		mcp.WithNumber("Repeat"),
	)

	// Add tool handler
	s.mcpServer.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		// Create input message
		req := &helloworld.HelloRequest{}
		if val, ok := request.Params.Arguments["Name"]; ok {
			if strVal, ok := val.(string); ok {
				req.Name = strVal
			} else {
				return nil, fmt.Errorf("Name must be a string")
			}
		}
		if val, ok := request.Params.Arguments["Language"]; ok {
			if strVal, ok := val.(string); ok {
				req.Language = strVal
			} else {
				return nil, fmt.Errorf("Language must be a string")
			}
		}
		if val, ok := request.Params.Arguments["Formal"]; ok {
			if boolVal, ok := val.(bool); ok {
				req.Formal = boolVal
			} else {
				return nil, fmt.Errorf("Formal must be a boolean")
			}
		}
		if val, ok := request.Params.Arguments["Repeat"]; ok {
			if numVal, ok := val.(float64); ok {
				req.Repeat = int32(numVal)
			} else {
				return nil, fmt.Errorf("Repeat must be a number")
			}
		}

		// Call the service method
		resp, err := s.server.StreamGreetings(ctx, req)
		if err != nil {
			return nil, err
		}

		// Convert response to MCP result
		return mcp.NewToolResultText(fmt.Sprintf("%+v", resp)), nil
	})

	return s
}

// Start starts the MCP server
func (s *GreeterMCPServer) Start() error {
	return server.ServeStdio(s.mcpServer)
}
