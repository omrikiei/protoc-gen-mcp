package generator

import (
	"fmt"
	"sort"
	"strconv"
	"strings"

	"github.com/omrikiei/protoc-gen-mcp/protogen/mcp"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
)

// Map of well-known protobuf types to their Go import paths and package names
var wellKnownTypes = map[string]struct {
	importPath string
	pkgName    string
}{
	"google.protobuf.FieldMask": {
		importPath: "google.golang.org/protobuf/types/known/fieldmaskpb",
		pkgName:    "fieldmaskpb",
	},
	"google.protobuf.Timestamp": {
		importPath: "google.golang.org/protobuf/types/known/timestamppb",
		pkgName:    "timestamppb",
	},
	"google.protobuf.Duration": {
		importPath: "google.golang.org/protobuf/types/known/durationpb",
		pkgName:    "durationpb",
	},
	"google.protobuf.Empty": {
		importPath: "google.golang.org/protobuf/types/known/emptypb",
		pkgName:    "emptypb",
	},
	"google.protobuf.Any": {
		importPath: "google.golang.org/protobuf/types/known/anypb",
		pkgName:    "anypb",
	},
	"google.protobuf.Struct": {
		importPath: "google.golang.org/protobuf/types/known/structpb",
		pkgName:    "structpb",
	},
	"google.protobuf.Value": {
		importPath: "google.golang.org/protobuf/types/known/structpb",
		pkgName:    "structpb",
	},
	"google.protobuf.ListValue": {
		importPath: "google.golang.org/protobuf/types/known/structpb",
		pkgName:    "structpb",
	},
	"google.protobuf.NullValue": {
		importPath: "google.golang.org/protobuf/types/known/structpb",
		pkgName:    "structpb",
	},
	"google.protobuf.BoolValue": {
		importPath: "google.golang.org/protobuf/types/known/wrapperspb",
		pkgName:    "wrapperspb",
	},
	"google.protobuf.Int32Value": {
		importPath: "google.golang.org/protobuf/types/known/wrapperspb",
		pkgName:    "wrapperspb",
	},
	"google.protobuf.Int64Value": {
		importPath: "google.golang.org/protobuf/types/known/wrapperspb",
		pkgName:    "wrapperspb",
	},
	"google.protobuf.UInt32Value": {
		importPath: "google.golang.org/protobuf/types/known/wrapperspb",
		pkgName:    "wrapperspb",
	},
	"google.protobuf.UInt64Value": {
		importPath: "google.golang.org/protobuf/types/known/wrapperspb",
		pkgName:    "wrapperspb",
	},
	"google.protobuf.FloatValue": {
		importPath: "google.golang.org/protobuf/types/known/wrapperspb",
		pkgName:    "wrapperspb",
	},
	"google.protobuf.DoubleValue": {
		importPath: "google.golang.org/protobuf/types/known/wrapperspb",
		pkgName:    "wrapperspb",
	},
	"google.protobuf.StringValue": {
		importPath: "google.golang.org/protobuf/types/known/wrapperspb",
		pkgName:    "wrapperspb",
	},
	"google.protobuf.BytesValue": {
		importPath: "google.golang.org/protobuf/types/known/wrapperspb",
		pkgName:    "wrapperspb",
	},
}

// GenerateFile generates the MCP server code for a proto file.
func GenerateFile(gen *protogen.Plugin, file *protogen.File) error {
	if len(file.Services) == 0 {
		return nil
	}

	// Check if any service has MCP annotations
	hasMCPService := false
	for _, service := range file.Services {
		if version, ok := proto.GetExtension(service.Desc.Options(), mcp.E_McpVersion).(string); ok && version != "" {
			hasMCPService = true
			break
		}
	}
	if !hasMCPService {
		return nil
	}

	// Check if any method in any service is annotated as a tool
	hasAnyTool := false
	for _, service := range file.Services {
		for _, method := range service.Methods {
			exposeAsTool, ok := proto.GetExtension(method.Desc.Options(), mcp.E_McpExposeAsTool).(bool)
			if ok && exposeAsTool {
				hasAnyTool = true
				break
			}
		}
		if hasAnyTool {
			break
		}
	}
	if !hasAnyTool {
		return nil
	}

	// Generate the MCP server package
	mcpFilename := file.GeneratedFilenamePrefix + ".mcp.pb.go"
	mcpG := gen.NewGeneratedFile(mcpFilename, file.GoImportPath)

	// Add imports
	mcpG.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "context",
		GoImportPath: "context",
	})
	mcpG.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "fmt",
		GoImportPath: "fmt",
	})
	mcpG.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "reflect",
		GoImportPath: "reflect",
	})
	mcpG.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "strings",
		GoImportPath: "strings",
	})
	mcpG.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "mcp",
		GoImportPath: "github.com/mark3labs/mcp-go/mcp",
	})
	mcpG.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "server",
		GoImportPath: "github.com/mark3labs/mcp-go/server",
	})
	mcpG.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "protojson",
		GoImportPath: "google.golang.org/protobuf/encoding/protojson",
	})
	mcpG.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "grpc",
		GoImportPath: "google.golang.org/grpc",
	})
	mcpG.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "structpb",
		GoImportPath: "google.golang.org/protobuf/types/known/structpb",
	})

	// Generate header
	mcpG.P("// Code generated by protoc-gen-mcp. DO NOT EDIT.")
	mcpG.P("// source: ", file.Desc.Path())
	mcpG.P()
	mcpG.P("package ", file.GoPackageName)
	mcpG.P()

	// Add wellKnownTypes map to the generated code
	mcpG.P("// Map of well-known protobuf types to their Go import paths and package names")
	mcpG.P("var wellKnownTypes = map[string]struct {")
	mcpG.P("	importPath string")
	mcpG.P("	pkgName    string")
	mcpG.P("}{")
	for protoName, wellKnownType := range wellKnownTypes {
		mcpG.P("	\"", protoName, "\": {")
		mcpG.P("		importPath: \"", wellKnownType.importPath, "\",")
		mcpG.P("		pkgName:    \"", wellKnownType.pkgName, "\",")
		mcpG.P("	},")
	}
	mcpG.P("}")
	mcpG.P()

	// Generate code for each service
	for _, service := range file.Services {
		if err := generateService(mcpG, service, file); err != nil {
			return err
		}
	}

	return nil
}

func generateService(g *protogen.GeneratedFile, service *protogen.Service, file *protogen.File) error {
	// Track packages we need to import
	importedPackages := make(map[string]string)

	// Check if this is an MCP service by looking for mcp_version
	mcpVersion, ok := proto.GetExtension(service.Desc.Options(), mcp.E_McpVersion).(string)
	if !ok || mcpVersion == "" {
		return nil
	}

	// Generate server interface
	g.P("// ", service.GoName, "MCPServer is the MCP server API for ", service.GoName, " service.")
	g.P("type ", service.GoName, "MCPServer interface {")
	for _, method := range service.Methods {
		exposeAsTool, ok := proto.GetExtension(method.Desc.Options(), mcp.E_McpExposeAsTool).(bool)
		if !ok || !exposeAsTool {
			continue
		}
		g.P(method.GoName, "(context.Context, *", method.Input.GoIdent, ", ...grpc.CallOption) (*", method.Output.GoIdent, ", error)")
	}
	g.P("}")
	g.P()

	// Generate MCP server implementation
	g.P("// ", service.GoName, "MCPServerImpl implements the MCP server for ", service.GoName, " service.")
	g.P("type ", service.GoName, "MCPServerImpl struct {")
	g.P("	server ", service.GoName, "MCPServer")
	g.P("	MCPServer *server.MCPServer")
	g.P("	tools []struct {")
	g.P("		tool mcp.Tool")
	g.P("		handler server.ToolHandlerFunc")
	g.P("	}")
	g.P("	resources []struct {")
	g.P("		resource mcp.Resource")
	g.P("		handler server.ResourceHandlerFunc")
	g.P("	}")
	g.P("}")
	g.P()

	// Generate MCP server constructor
	g.P("// New", service.GoName, "MCPServer creates a new MCP server for ", service.GoName, " service.")
	g.P("func New", service.GoName, "MCPServer(srv ", service.GoName, "MCPServer) *", service.GoName, "MCPServerImpl {")
	g.P("	s := &", service.GoName, "MCPServerImpl{")
	g.P("		server: srv,")
	g.P("		MCPServer: server.NewMCPServer(")
	g.P("			\"", service.GoName, "\",")
	g.P("			\"", mcpVersion, "\",")
	g.P("		),")
	g.P("		tools: make([]struct {")
	g.P("			tool mcp.Tool")
	g.P("			handler server.ToolHandlerFunc")
	g.P("		}, 0),")
	g.P("		resources: make([]struct {")
	g.P("			resource mcp.Resource")
	g.P("			handler server.ResourceHandlerFunc")
	g.P("		}, 0),")
	g.P("	}")
	g.P()
	g.P("	// Register resources for request and response messages")
	firstResource := true
	for _, method := range service.Methods {
		// Only register resources for methods that are exposed as tools
		exposeAsTool, ok := proto.GetExtension(method.Desc.Options(), mcp.E_McpExposeAsTool).(bool)
		if !ok || !exposeAsTool {
			continue
		}

		// Register input message as resource if annotated or used by a tool
		inputExpose, _ := proto.GetExtension(method.Input.Desc.Options(), mcp.E_McpExposeAsResource).(bool)
		if exposeAsTool || inputExpose {
			g.P("\t// Register ", method.Input.GoIdent, " as resource")
			if firstResource {
				g.P("\tresource := mcp.Resource{")
				firstResource = false
			} else {
				g.P("\tresource = mcp.Resource{")
			}
			g.P("\t\tURI: \"", method.Input.GoIdent, "\",")
			g.P("\t\tName: \"", method.Input.GoIdent, "\",")
			g.P("\t\tDescription: \"Request message for ", method.GoName, " method\",")
			g.P("\t\tMIMEType: \"application/json\",")
			g.P("\t}")
			g.P("\ts.resources = append(s.resources, struct {")
			g.P("\t\tresource mcp.Resource")
			g.P("\t\thandler server.ResourceHandlerFunc")
			g.P("\t}{")
			g.P("\t\tresource: resource,")
			g.P("\t\thandler: func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {")
			g.P("\t\t\t// Create a new instance of the request message")
			g.P("\t\t\treq := &", method.Input.GoIdent, "{}")
			g.P("\t\t\t// Convert request parameters to message fields")
			g.P("\t\t\tif err := convertParamsToMessage(request.Params.Arguments, req); err != nil {")
			g.P("\t\t\t\treturn nil, err")
			g.P("\t\t\t}")
			g.P("\t\t\t// Serialize the message to JSON")
			g.P("\t\t\tjsonBytes, err := protojson.Marshal(req)")
			g.P("\t\t\tif err != nil {")
			g.P("\t\t\t\treturn nil, fmt.Errorf(\"failed to serialize message: %v\", err)")
			g.P("\t\t\t}")
			g.P("\t\t\treturn []mcp.ResourceContents{mcp.TextResourceContents{")
			g.P("\t\t\t\tText: string(jsonBytes),")
			g.P("\t\t\t}}, nil")
			g.P("\t\t},")
			g.P("\t})")
			g.P()
		}

		// Register output message as resource if annotated or used by a tool
		outputExpose, _ := proto.GetExtension(method.Output.Desc.Options(), mcp.E_McpExposeAsResource).(bool)
		if exposeAsTool || outputExpose {
			g.P("\t// Register ", method.Output.GoIdent, " as resource")
			g.P("\tresource = mcp.Resource{")
			g.P("\t\tURI: \"", method.Output.GoIdent, "\",")
			g.P("\t\tName: \"", method.Output.GoIdent, "\",")
			g.P("\t\tDescription: \"Response message for ", method.GoName, " method\",")
			g.P("\t\tMIMEType: \"application/json\",")
			g.P("\t}")
			g.P("\ts.resources = append(s.resources, struct {")
			g.P("\t\tresource mcp.Resource")
			g.P("\t\thandler server.ResourceHandlerFunc")
			g.P("\t}{")
			g.P("\t\tresource: resource,")
			g.P("\t\thandler: func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {")
			g.P("\t\t\t// Create a new instance of the response message")
			g.P("\t\t\tresp := &", method.Output.GoIdent, "{}")
			g.P("\t\t\t// Convert request parameters to message fields")
			g.P("\t\t\tif err := convertParamsToMessage(request.Params.Arguments, resp); err != nil {")
			g.P("\t\t\t\treturn nil, err")
			g.P("\t\t\t}")
			g.P("\t\t\t// Serialize the message to JSON")
			g.P("\t\t\tjsonBytes, err := protojson.Marshal(resp)")
			g.P("\t\t\tif err != nil {")
			g.P("\t\t\t\treturn nil, fmt.Errorf(\"failed to serialize message: %v\", err)")
			g.P("\t\t\t}")
			g.P("\t\t\treturn []mcp.ResourceContents{mcp.TextResourceContents{")
			g.P("\t\t\t\tText: string(jsonBytes),")
			g.P("\t\t\t}}, nil")
			g.P("\t\t},")
			g.P("\t})")
			g.P()
		}
	}

	// Register all messages defined in the proto file as resources
	g.P("\t// Register all messages defined in the proto file as resources")
	for _, message := range file.Messages {
		// Check if this message should be exposed as a resource
		exposeAsResource, ok := proto.GetExtension(message.Desc.Options(), mcp.E_McpExposeAsResource).(bool)
		if !ok || !exposeAsResource {
			continue
		}

		// Skip if this message is already registered as a request/response
		isRegistered := false
		for _, method := range service.Methods {
			// Only consider methods that are exposed as tools
			exposeAsTool, ok := proto.GetExtension(method.Desc.Options(), mcp.E_McpExposeAsTool).(bool)
			if !ok || !exposeAsTool {
				continue
			}
			if method.Input.GoIdent == message.GoIdent || method.Output.GoIdent == message.GoIdent {
				isRegistered = true
				break
			}
		}
		if isRegistered {
			continue
		}

		// Get message description from annotation or generate JSON template
		description := "Message type " + string(message.GoIdent.GoName)
		if desc, ok := proto.GetExtension(message.Desc.Options(), mcp.E_McpMessageDescription).(string); ok && desc != "" {
			description = desc
		} else {
			description += "\n\nJSON Template:\n" + generateMessageJSONTemplate(message)
		}

		g.P("	// Register ", message.GoIdent, " as resource")
		g.P("	resource = mcp.Resource{")
		g.P("		URI: \"", message.GoIdent, "\",")
		g.P("		Name: \"", message.GoIdent, "\",")
		g.P("		Description: `", description, "`,")
		g.P("		MIMEType: \"application/json\",")
		g.P("	}")
		g.P("	s.resources = append(s.resources, struct {")
		g.P("		resource mcp.Resource")
		g.P("		handler server.ResourceHandlerFunc")
		g.P("	}{")
		g.P("		resource: resource,")
		g.P("		handler: func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {")
		g.P("			// Create a new instance of the message")
		g.P("			msg := &", message.GoIdent, "{}")
		// Convert request parameters to message fields
		g.P("			if err := convertParamsToMessage(request.Params.Arguments, msg); err != nil {")
		g.P("				return nil, err")
		g.P("			}")
		g.P("			// Serialize the message to JSON")
		g.P("			jsonBytes, err := protojson.Marshal(msg)")
		g.P("			if err != nil {")
		g.P("				return nil, fmt.Errorf(\"failed to serialize message: %v\", err)")
		g.P("			}")
		g.P("			return []mcp.ResourceContents{mcp.TextResourceContents{")
		g.P("				Text: string(jsonBytes),")
		g.P("			}}, nil")
		g.P("		},")
		g.P("	})")
		g.P()
	}

	// Generate tools for each method
	var hasCreatedTool bool
	for _, method := range service.Methods {
		created, err := generateMethodTool(g, service, method, hasCreatedTool, string(file.GoPackageName), importedPackages)
		if err != nil {
			return err
		}
		if created {
			hasCreatedTool = true
		}
	}
	g.P("	return s")
	g.P("}")
	g.P()

	// Generate method to start the server
	g.P("// Start starts the MCP server")
	g.P("func (s *", service.GoName, "MCPServerImpl) Start() error {")
	g.P("	return server.ServeStdio(s.MCPServer)")
	g.P("}")
	g.P()

	// Add getter methods after the Start method
	g.P("// Tools returns all registered tools")
	g.P("func (s *", service.GoName, "MCPServerImpl) Tools() []struct {")
	g.P("	Tool mcp.Tool")
	g.P("	Handler server.ToolHandlerFunc")
	g.P("} {")
	g.P("	result := make([]struct {")
	g.P("		Tool mcp.Tool")
	g.P("		Handler server.ToolHandlerFunc")
	g.P("	}, len(s.tools))")
	g.P("	for i, t := range s.tools {")
	g.P("		result[i] = struct {")
	g.P("			Tool mcp.Tool")
	g.P("			Handler server.ToolHandlerFunc")
	g.P("		}{")
	g.P("			Tool: t.tool,")
	g.P("			Handler: t.handler,")
	g.P("		}")
	g.P("	}")
	g.P("	return result")
	g.P("}")
	g.P()

	g.P("// Resources returns all registered resources")
	g.P("func (s *", service.GoName, "MCPServerImpl) Resources() []struct {")
	g.P("	Resource mcp.Resource")
	g.P("	Handler server.ResourceHandlerFunc")
	g.P("} {")
	g.P("	result := make([]struct {")
	g.P("		Resource mcp.Resource")
	g.P("		Handler server.ResourceHandlerFunc")
	g.P("	}, len(s.resources))")
	g.P("	for i, r := range s.resources {")
	g.P("		result[i] = struct {")
	g.P("			Resource mcp.Resource")
	g.P("			Handler server.ResourceHandlerFunc")
	g.P("		}{")
	g.P("			Resource: r.resource,")
	g.P("			Handler: r.handler,")
	g.P("		}")
	g.P("	}")
	g.P("	return result")
	g.P("}")
	g.P()

	g.P("// Merge adds this server's tools and resources to the given MCP server")
	g.P("func (s *", service.GoName, "MCPServerImpl) Merge(target *server.MCPServer) {")
	g.P("	// Add tools")
	g.P("	for _, t := range s.tools {")
	g.P("		target.AddTool(t.tool, t.handler)")
	g.P("	}")
	g.P()
	g.P("	// Add resources")
	g.P("	for _, r := range s.resources {")
	g.P("		target.AddResource(r.resource, r.handler)")
	g.P("	}")
	g.P("}")
	g.P()

	// Generate helper function to convert parameters to message fields
	g.P("// convertParamsToMessage converts MCP parameters to message fields")
	g.P("func convertParamsToMessage(params map[string]interface{}, msg interface{}) error {")
	g.P("	// Get the message type")
	g.P("	msgType := reflect.TypeOf(msg).Elem()")
	g.P("	msgValue := reflect.ValueOf(msg).Elem()")
	g.P()
	g.P("	// Check if this is a well-known type")
	g.P("	fullName := msgType.PkgPath() + \".\" + msgType.Name()")
	g.P("	for protoName, wellKnownType := range wellKnownTypes {")
	g.P("		if wellKnownType.importPath+\".\"+msgType.Name() == fullName {")
	g.P("			// Handle well-known types")
	g.P("			switch protoName {")
	g.P("			case \"google.protobuf.Timestamp\":")
	g.P("				// Try different field name variations for seconds")
	g.P("				var seconds interface{}")
	g.P("				var ok bool")
	g.P("				if seconds, ok = params[\"seconds\"]; !ok {")
	g.P("					if seconds, ok = params[\"Seconds\"]; !ok {")
	g.P("						return nil")
	g.P("					}")
	g.P("				}")
	g.P("				if numVal, ok := seconds.(float64); ok {")
	g.P("					msgValue.FieldByName(\"Seconds\").SetInt(int64(numVal))")
	g.P("				}")

	g.P("				// Try different field name variations for nanos")
	g.P("				var nanos interface{}")
	g.P("				if nanos, ok = params[\"nanos\"]; !ok {")
	g.P("					if nanos, ok = params[\"Nanos\"]; !ok {")
	g.P("						return nil")
	g.P("					}")
	g.P("				}")
	g.P("				if numVal, ok := nanos.(float64); ok {")
	g.P("					msgValue.FieldByName(\"Nanos\").SetInt(int64(numVal))")
	g.P("				}")
	g.P("				return nil")
	g.P("			case \"google.protobuf.Duration\":")
	g.P("				// Try different field name variations for seconds")
	g.P("				var seconds interface{}")
	g.P("				var ok bool")
	g.P("				if seconds, ok = params[\"seconds\"]; !ok {")
	g.P("					if seconds, ok = params[\"Seconds\"]; !ok {")
	g.P("						return nil")
	g.P("					}")
	g.P("				}")
	g.P("				if numVal, ok := seconds.(float64); ok {")
	g.P("					msgValue.FieldByName(\"Seconds\").SetInt(int64(numVal))")
	g.P("				}")

	g.P("				// Try different field name variations for nanos")
	g.P("				var nanos interface{}")
	g.P("				if nanos, ok = params[\"nanos\"]; !ok {")
	g.P("					if nanos, ok = params[\"Nanos\"]; !ok {")
	g.P("						return nil")
	g.P("					}")
	g.P("				}")
	g.P("				if numVal, ok := nanos.(float64); ok {")
	g.P("					msgValue.FieldByName(\"Nanos\").SetInt(int64(numVal))")
	g.P("				}")
	g.P("				return nil")
	g.P("			case \"google.protobuf.FieldMask\":")
	g.P("				// Try different field name variations")
	g.P("				var paths interface{}")
	g.P("				var ok bool")
	g.P("				if paths, ok = params[\"paths\"]; !ok {")
	g.P("					if paths, ok = params[\"Paths\"]; !ok {")
	g.P("						return nil")
	g.P("					}")
	g.P("				}")
	g.P("				if pathsArr, ok := paths.([]interface{}); ok {")
	g.P("					pathsSlice := make([]string, len(pathsArr))")
	g.P("					for i, path := range pathsArr {")
	g.P("						if strPath, ok := path.(string); ok {")
	g.P("							pathsSlice[i] = strPath")
	g.P("						}")
	g.P("					}")
	g.P("					msgValue.FieldByName(\"Paths\").Set(reflect.ValueOf(pathsSlice))")
	g.P("				}")
	g.P("				return nil")
	g.P("			case \"google.protobuf.Empty\":")
	g.P("				// Empty message has no fields")
	g.P("				return nil")
	g.P("			case \"google.protobuf.Any\":")
	g.P("				// Try different field name variations for type_url")
	g.P("				var typeURL interface{}")
	g.P("				var ok bool")
	g.P("				if typeURL, ok = params[\"type_url\"]; !ok {")
	g.P("					if typeURL, ok = params[\"typeUrl\"]; !ok {")
	g.P("						if typeURL, ok = params[\"TypeUrl\"]; !ok {")
	g.P("							return nil")
	g.P("						}")
	g.P("					}")
	g.P("				}")
	g.P("				if strVal, ok := typeURL.(string); ok {")
	g.P("					msgValue.FieldByName(\"TypeUrl\").SetString(strVal)")
	g.P("				}")

	g.P("				// Try different field name variations for value")
	g.P("				var value interface{}")
	g.P("				if value, ok = params[\"value\"]; !ok {")
	g.P("					if value, ok = params[\"Value\"]; !ok {")
	g.P("						return nil")
	g.P("					}")
	g.P("				}")
	g.P("				if bytesVal, ok := value.([]byte); ok {")
	g.P("					msgValue.FieldByName(\"Value\").SetBytes(bytesVal)")
	g.P("				}")
	g.P("				return nil")
	g.P("			case \"google.protobuf.Struct\":")
	g.P("				if fields, ok := params[\"fields\"].(map[string]interface{}); ok {")
	g.P("					// Create a new map for the fields")
	g.P("					fieldsMap := reflect.MakeMap(msgValue.FieldByName(\"Fields\").Type())")
	g.P("					for k, v := range fields {")
	g.P("						// Create a new Value message")
	g.P("						valueMsg := reflect.New(msgValue.FieldByName(\"Fields\").Type().Elem().Elem())")
	g.P("						if err := convertParamsToMessage(map[string]interface{}{\"value\": v}, valueMsg.Interface()); err != nil {")
	g.P("							return err")
	g.P("						}")
	g.P("						fieldsMap.SetMapIndex(reflect.ValueOf(k), valueMsg)")
	g.P("					}")
	g.P("					msgValue.FieldByName(\"Fields\").Set(fieldsMap)")
	g.P("				}")
	g.P("				return nil")
	g.P("			case \"google.protobuf.Value\":")
	g.P("				if nullVal, ok := params[\"null_value\"].(float64); ok {")
	g.P("					msgValue.FieldByName(\"Kind\").Set(reflect.ValueOf(&structpb.Value_NullValue{NullValue: structpb.NullValue(nullVal)}))")
	g.P("				} else if numVal, ok := params[\"number_value\"].(float64); ok {")
	g.P("					msgValue.FieldByName(\"Kind\").Set(reflect.ValueOf(&structpb.Value_NumberValue{NumberValue: numVal}))")
	g.P("				} else if strVal, ok := params[\"string_value\"].(string); ok {")
	g.P("					msgValue.FieldByName(\"Kind\").Set(reflect.ValueOf(&structpb.Value_StringValue{StringValue: strVal}))")
	g.P("				} else if boolVal, ok := params[\"bool_value\"].(bool); ok {")
	g.P("					msgValue.FieldByName(\"Kind\").Set(reflect.ValueOf(&structpb.Value_BoolValue{BoolValue: boolVal}))")
	g.P("				} else if structVal, ok := params[\"struct_value\"].(map[string]interface{}); ok {")
	g.P("					structMsg := &structpb.Struct{}")
	g.P("					if err := convertParamsToMessage(structVal, structMsg); err != nil {")
	g.P("						return err")
	g.P("					}")
	g.P("					msgValue.FieldByName(\"Kind\").Set(reflect.ValueOf(&structpb.Value_StructValue{StructValue: structMsg}))")
	g.P("				} else if listVal, ok := params[\"list_value\"].([]interface{}); ok {")
	g.P("					listMsg := &structpb.ListValue{}")
	g.P("					if err := convertParamsToMessage(map[string]interface{}{\"values\": listVal}, listMsg); err != nil {")
	g.P("						return err")
	g.P("					}")
	g.P("					msgValue.FieldByName(\"Kind\").Set(reflect.ValueOf(&structpb.Value_ListValue{ListValue: listMsg}))")
	g.P("				}")
	g.P("				return nil")
	g.P("			case \"google.protobuf.ListValue\":")
	g.P("				if values, ok := params[\"values\"].([]interface{}); ok {")
	g.P("					valuesSlice := reflect.MakeSlice(msgValue.FieldByName(\"Values\").Type(), len(values), len(values))")
	g.P("					for i, v := range values {")
	g.P("						valueMsg := &structpb.Value{}")
	g.P("						if err := convertParamsToMessage(map[string]interface{}{\"value\": v}, valueMsg); err != nil {")
	g.P("							return err")
	g.P("						}")
	g.P("						valuesSlice.Index(i).Set(reflect.ValueOf(valueMsg))")
	g.P("					}")
	g.P("					msgValue.FieldByName(\"Values\").Set(valuesSlice)")
	g.P("				}")
	g.P("				return nil")
	g.P("			case \"google.protobuf.BoolValue\",")
	g.P("				\"google.protobuf.Int32Value\",")
	g.P("				\"google.protobuf.Int64Value\",")
	g.P("				\"google.protobuf.UInt32Value\",")
	g.P("				\"google.protobuf.UInt64Value\",")
	g.P("				\"google.protobuf.FloatValue\",")
	g.P("				\"google.protobuf.DoubleValue\",")
	g.P("				\"google.protobuf.StringValue\",")
	g.P("				\"google.protobuf.BytesValue\":")
	g.P("				if val, ok := params[\"value\"]; ok {")
	g.P("					switch protoName {")
	g.P("					case \"google.protobuf.BoolValue\":")
	g.P("						if boolVal, ok := val.(bool); ok {")
	g.P("							msgValue.FieldByName(\"Value\").SetBool(boolVal)")
	g.P("						}")
	g.P("					case \"google.protobuf.Int32Value\":")
	g.P("						if numVal, ok := val.(float64); ok {")
	g.P("							msgValue.FieldByName(\"Value\").SetInt(int64(numVal))")
	g.P("						}")
	g.P("					case \"google.protobuf.Int64Value\":")
	g.P("						if numVal, ok := val.(float64); ok {")
	g.P("							msgValue.FieldByName(\"Value\").SetInt(int64(numVal))")
	g.P("						}")
	g.P("					case \"google.protobuf.UInt32Value\":")
	g.P("						if numVal, ok := val.(float64); ok {")
	g.P("							msgValue.FieldByName(\"Value\").SetUint(uint64(numVal))")
	g.P("						}")
	g.P("					case \"google.protobuf.UInt64Value\":")
	g.P("						if numVal, ok := val.(float64); ok {")
	g.P("							msgValue.FieldByName(\"Value\").SetUint(uint64(numVal))")
	g.P("						}")
	g.P("					case \"google.protobuf.FloatValue\":")
	g.P("						if numVal, ok := val.(float64); ok {")
	g.P("							msgValue.FieldByName(\"Value\").SetFloat(float64(numVal))")
	g.P("						}")
	g.P("					case \"google.protobuf.DoubleValue\":")
	g.P("						if numVal, ok := val.(float64); ok {")
	g.P("							msgValue.FieldByName(\"Value\").SetFloat(numVal)")
	g.P("						}")
	g.P("					case \"google.protobuf.StringValue\":")
	g.P("						if strVal, ok := val.(string); ok {")
	g.P("							msgValue.FieldByName(\"Value\").SetString(strVal)")
	g.P("						}")
	g.P("					case \"google.protobuf.BytesValue\":")
	g.P("						if strVal, ok := val.(string); ok {")
	g.P("							msgValue.FieldByName(\"Value\").SetBytes([]byte(strVal))")
	g.P("						}")
	g.P("					}")
	g.P("				}")
	g.P("				return nil")
	g.P("			}")
	g.P("		}")
	g.P("	}")
	g.P()
	g.P("	// Use reflection to set message fields for non-well-known types")
	g.P("	typ := msgValue.Type()")
	g.P()
	g.P("	for i := 0; i < msgValue.NumField(); i++ {")
	g.P("		field := msgValue.Field(i)")
	g.P("		fieldType := typ.Field(i)")
	g.P()
	g.P("		// Get field name from protobuf tag")
	g.P("		tag := fieldType.Tag.Get(\"protobuf\")")
	g.P("		if tag == \"\" {")
	g.P("			continue")
	g.P("		}")
	g.P()
	g.P("		// Extract field name from protobuf tag")
	g.P("		parts := strings.Split(tag, \",\")")
	g.P("		var fieldName string")
	g.P("		for _, part := range parts {")
	g.P("			if strings.HasPrefix(part, \"name=\") {")
	g.P("				fieldName = strings.TrimPrefix(part, \"name=\")")
	g.P("				break")
	g.P("			}")
	g.P("		}")
	g.P("		if fieldName == \"\" {")
	g.P("			continue")
	g.P("		}")
	g.P()
	g.P("		// Get value from params using the protobuf field name")
	g.P("		paramVal, ok := params[fieldName]")
	g.P("		if !ok {")
	g.P("			// Try with JSON name as fallback")
	g.P("			jsonTag := fieldType.Tag.Get(\"json\")")
	g.P("			if jsonTag != \"\" {")
	g.P("				jsonParts := strings.Split(jsonTag, \",\")")
	g.P("				jsonName := jsonParts[0]")
	g.P("				if jsonName != \"\" && jsonName != \"-\" {")
	g.P("					paramVal, ok = params[jsonName]")
	g.P("				}")
	g.P("				// Try with GoName as last resort")
	g.P("				if !ok {")
	g.P("					paramVal, ok = params[fieldType.Name]")
	g.P("				}")
	g.P("				if !ok {")
	g.P("					continue")
	g.P("				}")
	g.P("			}")
	g.P("		}")
	g.P()
	g.P("		// Convert and set field value based on type")
	g.P("		switch field.Kind() {")
	g.P("		case reflect.String:")
	g.P("			if strVal, ok := paramVal.(string); ok {")
	g.P("				field.SetString(strVal)")
	g.P("			}")
	g.P("		case reflect.Int32, reflect.Int64:")
	g.P("			if numVal, ok := paramVal.(float64); ok {")
	g.P("				field.SetInt(int64(numVal))")
	g.P("			}")
	g.P("		case reflect.Uint32, reflect.Uint64:")
	g.P("			if numVal, ok := paramVal.(float64); ok {")
	g.P("				field.SetUint(uint64(numVal))")
	g.P("			}")
	g.P("		case reflect.Bool:")
	g.P("			if boolVal, ok := paramVal.(bool); ok {")
	g.P("				field.SetBool(boolVal)")
	g.P("			}")
	g.P("		case reflect.Slice:")
	g.P("			if arrVal, ok := paramVal.([]interface{}); ok {")
	g.P("				slice := reflect.MakeSlice(field.Type(), len(arrVal), len(arrVal))")
	g.P("				for j, v := range arrVal {")
	g.P("					switch field.Type().Elem().Kind() {")
	g.P("					case reflect.String:")
	g.P("						if strVal, ok := v.(string); ok {")
	g.P("							slice.Index(j).SetString(strVal)")
	g.P("						}")
	g.P("					case reflect.Int32, reflect.Int64:")
	g.P("						if numVal, ok := v.(float64); ok {")
	g.P("							slice.Index(j).SetInt(int64(numVal))")
	g.P("						}")
	g.P("					case reflect.Uint32, reflect.Uint64:")
	g.P("						if numVal, ok := v.(float64); ok {")
	g.P("							slice.Index(j).SetUint(uint64(numVal))")
	g.P("						}")
	g.P("					case reflect.Bool:")
	g.P("						if boolVal, ok := v.(bool); ok {")
	g.P("							slice.Index(j).SetBool(boolVal)")
	g.P("						}")
	g.P("					case reflect.Ptr:")
	g.P("						if mapVal, ok := v.(map[string]interface{}); ok {")
	g.P("							// Create a new instance of the nested message")
	g.P("							nestedMsg := reflect.New(field.Type().Elem().Elem())")
	g.P("							// Convert nested message fields")
	g.P("							if err := convertParamsToMessage(mapVal, nestedMsg.Interface()); err != nil {")
	g.P("								return fmt.Errorf(\"failed to convert nested message at index %d: %v\", j, err)")
	g.P("							}")
	g.P("							slice.Index(j).Set(nestedMsg)")
	g.P("						}")
	g.P("					}")
	g.P("				}")
	g.P("				field.Set(slice)")
	g.P("			}")
	g.P("		case reflect.Ptr:")
	g.P("			if mapVal, ok := paramVal.(map[string]interface{}); ok {")
	g.P("				// Create a new instance of the nested message")
	g.P("				nestedMsg := reflect.New(field.Type().Elem())")
	g.P("				// Convert nested message fields")
	g.P("				if err := convertParamsToMessage(mapVal, nestedMsg.Interface()); err != nil {")
	g.P("					return fmt.Errorf(\"failed to convert nested message: %v\", err)")
	g.P("				}")
	g.P("				field.Set(nestedMsg)")
	g.P("			}")
	g.P("		case reflect.Map:")
	g.P("			if mapVal, ok := paramVal.(map[string]interface{}); ok {")
	g.P("				newMap := reflect.MakeMap(field.Type())")
	g.P("				for k, v := range mapVal {")
	g.P("					key := reflect.ValueOf(k)")
	g.P("					var value reflect.Value")
	g.P("					switch field.Type().Elem().Kind() {")
	g.P("					case reflect.String:")
	g.P("						if strVal, ok := v.(string); ok {")
	g.P("							value = reflect.ValueOf(strVal)")
	g.P("						}")
	g.P("					case reflect.Int32, reflect.Int64:")
	g.P("						if numVal, ok := v.(float64); ok {")
	g.P("							value = reflect.ValueOf(int64(numVal))")
	g.P("						}")
	g.P("					case reflect.Uint32, reflect.Uint64:")
	g.P("						if numVal, ok := v.(float64); ok {")
	g.P("							value = reflect.ValueOf(uint64(numVal))")
	g.P("						}")
	g.P("					case reflect.Bool:")
	g.P("						if boolVal, ok := v.(bool); ok {")
	g.P("							value = reflect.ValueOf(boolVal)")
	g.P("						}")
	g.P("					case reflect.Ptr:")
	g.P("						if mapVal, ok := v.(map[string]interface{}); ok {")
	g.P("							// Create a new instance of the nested message")
	g.P("							nestedMsg := reflect.New(field.Type().Elem().Elem())")
	g.P("							// Convert nested message fields")
	g.P("							if err := convertParamsToMessage(mapVal, nestedMsg.Interface()); err != nil {")
	g.P("								return fmt.Errorf(\"failed to convert nested message in map: %v\", err)")
	g.P("							}")
	g.P("							value = nestedMsg")
	g.P("						}")
	g.P("					}")
	g.P("					if value.IsValid() {")
	g.P("						newMap.SetMapIndex(key, value)")
	g.P("					}")
	g.P("				}")
	g.P("				field.Set(newMap)")
	g.P("			}")
	g.P("		}")
	g.P("	}")
	g.P()
	g.P("	return nil")
	g.P("}")
	g.P()

	// Add imports for any packages we used
	for importPath := range importedPackages {
		g.QualifiedGoIdent(protogen.GoIdent{
			GoImportPath: protogen.GoImportPath(importPath),
		})
	}

	return nil
}

func generateMethodTool(g *protogen.GeneratedFile, service *protogen.Service, method *protogen.Method, hasCreatedTool bool, currentPkg string, importedPackages map[string]string) (bool, error) {
	// Check if this method should be exposed as a tool
	exposeAsTool, ok := proto.GetExtension(method.Desc.Options(), mcp.E_McpExposeAsTool).(bool)
	if !ok || !exposeAsTool {
		return false, nil
	}

	// Check if this is an MCP method by looking for mcp_tool_description
	mcpDescription, ok := proto.GetExtension(method.Desc.Options(), mcp.E_McpToolDescription).(string)
	if !ok || mcpDescription == "" {
		return false, nil
	}

	// Get MCP method options
	mcpTitle := proto.GetExtension(method.Desc.Options(), mcp.E_McpToolTitle).(string)
	mcpReadOnly := proto.GetExtension(method.Desc.Options(), mcp.E_McpToolReadOnly).(bool)
	mcpDestructive := proto.GetExtension(method.Desc.Options(), mcp.E_McpToolDestructive).(bool)
	mcpIdempotent := proto.GetExtension(method.Desc.Options(), mcp.E_McpToolIdempotent).(bool)
	mcpOpenWorld := proto.GetExtension(method.Desc.Options(), mcp.E_McpToolOpenWorld).(bool)

	// Generate tool creation
	g.P("	// Create tool for ", method.GoName)
	if !hasCreatedTool {
		g.P("	tool := mcp.NewTool(\"", method.GoName, "\",")
	} else {
		g.P("	tool = mcp.NewTool(\"", method.GoName, "\",")
	}
	if mcpDescription != "" {
		g.P("		mcp.WithDescription(\"", mcpDescription, "\"),")
	}
	if mcpTitle != "" || mcpReadOnly || mcpDestructive || mcpIdempotent || mcpOpenWorld {
		g.P("		mcp.WithToolAnnotation(mcp.ToolAnnotation{")
		if mcpTitle != "" {
			g.P("			Title:           \"", mcpTitle, "\",")
		}
		g.P("			ReadOnlyHint:    ", mcpReadOnly, ",")
		g.P("			DestructiveHint: ", mcpDestructive, ",")
		g.P("			IdempotentHint:  ", mcpIdempotent, ",")
		g.P("			OpenWorldHint:   ", mcpOpenWorld, ",")
		g.P("		}),")
	}

	// Add parameters for each field in the input message
	for _, field := range method.Input.Fields {
		fieldDesc := proto.GetExtension(field.Desc.Options(), mcp.E_McpFieldDescription).(string)
		isRequired := proto.GetExtension(field.Desc.Options(), mcp.E_McpRequired).(bool)
		validationPattern := proto.GetExtension(field.Desc.Options(), mcp.E_McpValidationPattern).(string)

		// Determine parameter type based on field type
		switch field.Desc.Kind() {
		case protoreflect.StringKind:
			if field.Desc.IsList() {
				g.P("		mcp.WithArray(\"", field.GoName, "\",")
			} else {
				g.P("		mcp.WithString(\"", field.GoName, "\",")
			}
			if isRequired {
				g.P("			mcp.Required(),")
			}
			if fieldDesc != "" {
				g.P("			mcp.Description(\"", fieldDesc, "\"),")
			}
			if validationPattern != "" {
				g.P("			mcp.Pattern(\"", validationPattern, "\"),")
			}
			g.P("		),")
		case protoreflect.BytesKind:
			if field.Desc.IsList() {
				g.P("		mcp.WithArray(\"", field.GoName, "\",")
			} else {
				g.P("		mcp.WithString(\"", field.GoName, "\",")
			}
			if isRequired {
				g.P("			mcp.Required(),")
			}
			if fieldDesc != "" {
				g.P("			mcp.Description(\"", fieldDesc, "\"),")
			}
			g.P("		),")
		case protoreflect.Int32Kind, protoreflect.Int64Kind,
			protoreflect.Uint32Kind, protoreflect.Uint64Kind:
			if field.Desc.IsList() {
				g.P("		mcp.WithArray(\"", field.GoName, "\",")
			} else {
				g.P("		mcp.WithNumber(\"", field.GoName, "\",")
			}
			if isRequired {
				g.P("			mcp.Required(),")
			}
			if fieldDesc != "" {
				g.P("			mcp.Description(\"", fieldDesc, "\"),")
			}
			g.P("		),")
		case protoreflect.BoolKind:
			if field.Desc.IsList() {
				g.P("		mcp.WithArray(\"", field.GoName, "\",")
			} else {
				g.P("		mcp.WithBoolean(\"", field.GoName, "\",")
			}
			if isRequired {
				g.P("			mcp.Required(),")
			}
			if fieldDesc != "" {
				g.P("			mcp.Description(\"", fieldDesc, "\"),")
			}
			g.P("		),")
		case protoreflect.MessageKind:
			if field.Desc.IsMap() {
				g.P("		mcp.WithObject(\"", field.GoName, "\",")
				// Add schema modification for map value type
				if field.Message != nil {
					g.P("			func(schema map[string]interface{}) {")
					if isRequired {
						g.P("				schema[\"required\"] = true")
					}
					if fieldDesc != "" {
						g.P("				schema[\"description\"] = ", strconv.Quote(fieldDesc))
					}
					g.P("				schema[\"additionalProperties\"] = ", generateSchemaMapString(generateMessageJSONSchema(field.Message, make(map[string]bool))), "")
					g.P("			},")
				}
				g.P("		),")
			} else if field.Desc.IsList() {
				g.P("		mcp.WithArray(\"", field.GoName, "\",")
				// Add schema modification for array item type
				if field.Message != nil {
					g.P("			func(schema map[string]interface{}) {")
					if isRequired {
						g.P("				schema[\"required\"] = true")
					}
					if fieldDesc != "" {
						g.P("				schema[\"description\"] = ", strconv.Quote(fieldDesc))
					}
					g.P("				schema[\"items\"] = ", generateSchemaMapString(generateMessageJSONSchema(field.Message, make(map[string]bool))), "")
					g.P("			},")
				}
				g.P("		),")
			} else {
				g.P("		mcp.WithObject(\"", field.GoName, "\",")
				// Add schema modification for nested object
				if field.Message != nil {
					g.P("			func(schema map[string]interface{}) {")
					if isRequired {
						g.P("				schema[\"required\"] = true")
					}
					if fieldDesc != "" {
						g.P("				schema[\"description\"] = ", strconv.Quote(fieldDesc))
					}
					g.P("				nestedSchema := ", generateSchemaMapString(generateMessageJSONSchema(field.Message, make(map[string]bool))), "")
					g.P("				for k, v := range nestedSchema {")
					g.P("					schema[k] = v")
					g.P("				}")
					g.P("			},")
				}
				g.P("		),")
			}
		case protoreflect.EnumKind:
			if field.Desc.IsList() {
				g.P("		mcp.WithArray(\"", field.GoName, "\",")
			} else {
				g.P("		mcp.WithString(\"", field.GoName, "\",")
			}
			if isRequired {
				g.P("			mcp.Required(),")
			}
			if fieldDesc != "" {
				g.P("			mcp.Description(\"", fieldDesc, "\"),")
			}
			if validationPattern != "" {
				g.P("			mcp.Pattern(\"", validationPattern, "\"),")
			}
			// Add enum values
			g.P("			mcp.Enum(", generateEnumValuesString(field.Enum), "...),")
			g.P("		),")
		}
	}
	g.P("	)")
	g.P()

	// Add tool handler
	g.P("	s.tools = append(s.tools, struct {")
	g.P("			tool mcp.Tool")
	g.P("			handler server.ToolHandlerFunc")
	g.P("	}{")
	g.P("		tool: tool,")
	g.P("		handler: func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {")
	g.P("			// Create input message")
	g.P("			req := &", method.Input.GoIdent, "{}")

	// Parse parameters from request
	for _, field := range method.Input.Fields {
		g.P("			if val, ok := request.Params.Arguments[\"", field.GoName, "\"]; ok {")
		switch field.Desc.Kind() {
		case protoreflect.StringKind:
			if field.Desc.IsList() {
				g.P("				if arrVal, ok := val.([]interface{}); ok {")
				g.P("					req.", field.GoName, " = make([]string, len(arrVal))")
				g.P("					for i, v := range arrVal {")
				g.P("						if strVal, ok := v.(string); ok {")
				g.P("							req.", field.GoName, "[i] = strVal")
				g.P("						} else {")
				g.P("							return nil, fmt.Errorf(\"", field.GoName, " must be an array of strings\")")
				g.P("						}")
				g.P("					}")
				g.P("				} else {")
				g.P("					return nil, fmt.Errorf(\"", field.GoName, " must be an array of strings\")")
				g.P("				}")
			} else {
				g.P("				if strVal, ok := val.(string); ok {")
				g.P("					req.", field.GoName, " = strVal")
				g.P("				} else {")
				g.P("					return nil, fmt.Errorf(\"", field.GoName, " must be a string\")")
				g.P("				}")
			}
		case protoreflect.BytesKind:
			if field.Desc.IsList() {
				g.P("				if arrVal, ok := val.([]interface{}); ok {")
				g.P("					req.", field.GoName, " = make([][]byte, len(arrVal))")
				g.P("					for i, v := range arrVal {")
				g.P("						if strVal, ok := v.(string); ok {")
				g.P("							req.", field.GoName, "[i] = []byte(strVal)")
				g.P("						} else {")
				g.P("							return nil, fmt.Errorf(\"", field.GoName, " must be an array of strings\")")
				g.P("						}")
				g.P("					}")
				g.P("				} else {")
				g.P("					return nil, fmt.Errorf(\"", field.GoName, " must be an array of strings\")")
				g.P("				}")
			} else {
				g.P("				if strVal, ok := val.(string); ok {")
				g.P("					req.", field.GoName, " = []byte(strVal)")
				g.P("				} else {")
				g.P("					return nil, fmt.Errorf(\"", field.GoName, " must be a string\")")
				g.P("				}")
			}
		case protoreflect.Int32Kind, protoreflect.Int64Kind,
			protoreflect.Uint32Kind, protoreflect.Uint64Kind:
			if field.Desc.IsList() {
				g.P("				if arrVal, ok := val.([]interface{}); ok {")
				g.P("					req.", field.GoName, " = make([]", getTypeName(field.Desc.Kind()), ", len(arrVal))")
				g.P("					for i, v := range arrVal {")
				g.P("						if numVal, ok := v.(float64); ok {")
				g.P("							req.", field.GoName, "[i] = ", getTypeConversion(field.Desc.Kind(), "int64(numVal)"))
				g.P("						} else {")
				g.P("							return nil, fmt.Errorf(\"", field.GoName, " must be an array of numbers\")")
				g.P("						}")
				g.P("					}")
				g.P("				} else {")
				g.P("					return nil, fmt.Errorf(\"", field.GoName, " must be an array of numbers\")")
				g.P("				}")
			} else {
				g.P("				if numVal, ok := val.(float64); ok {")
				g.P("					req.", field.GoName, " = ", getTypeConversion(field.Desc.Kind(), "int64(numVal)"))
				g.P("				} else {")
				g.P("					return nil, fmt.Errorf(\"", field.GoName, " must be a number\")")
				g.P("				}")
			}
		case protoreflect.BoolKind:
			if field.Desc.IsList() {
				g.P("				if arrVal, ok := val.([]interface{}); ok {")
				g.P("					req.", field.GoName, " = make([]bool, len(arrVal))")
				g.P("					for i, v := range arrVal {")
				g.P("						if boolVal, ok := v.(bool); ok {")
				g.P("							req.", field.GoName, "[i] = boolVal")
				g.P("						} else {")
				g.P("							return nil, fmt.Errorf(\"", field.GoName, " must be an array of booleans\")")
				g.P("						}")
				g.P("					}")
				g.P("				} else {")
				g.P("					return nil, fmt.Errorf(\"", field.GoName, " must be an array of booleans\")")
				g.P("				}")
			} else {
				g.P("				if boolVal, ok := val.(bool); ok {")
				g.P("					req.", field.GoName, " = boolVal")
				g.P("				} else {")
				g.P("					return nil, fmt.Errorf(\"", field.GoName, " must be a boolean\")")
				g.P("				}")
			}
		case protoreflect.MessageKind:
			if field.Desc.IsMap() {
				g.P("				if mapVal, ok := val.(map[string]interface{}); ok {")
				g.P("					req.", field.GoName, " = make(map[string]", getMapValueType(field, service, importedPackages), ")")
				g.P("					for k, v := range mapVal {")
				g.P("						var value ", getMapValueType(field, service, importedPackages))
				g.P("						", getMapValueConversion(field, "v", "value", service, currentPkg, importedPackages))
				g.P("						req.", field.GoName, "[k] = value")
				g.P("					}")
				g.P("				} else {")
				g.P("					return nil, fmt.Errorf(\"", field.GoName, " must be a map\")")
				g.P("				}")
			} else if field.Desc.IsList() {
				g.P("				if arrVal, ok := val.([]interface{}); ok {")
				g.P("					req.", field.GoName, " = make([]*", field.Message.GoIdent, ", len(arrVal))")
				g.P("					for i, v := range arrVal {")
				g.P("						if msgVal, ok := v.(map[string]interface{}); ok {")
				g.P("							// Create a new instance of the nested message")
				g.P("							nestedMsg := &", field.Message.GoIdent, "{}")
				g.P("							// Convert nested message fields")
				g.P("							if err := convertParamsToMessage(msgVal, nestedMsg); err != nil {")
				g.P("								return nil, fmt.Errorf(\"failed to convert nested message at index %d: %v\", i, err)")
				g.P("							}")
				g.P("							req.", field.GoName, "[i] = nestedMsg")
				g.P("						} else {")
				g.P("							return nil, fmt.Errorf(\"", field.GoName, " must be an array of messages\")")
				g.P("						}")
				g.P("					}")
				g.P("				} else {")
				g.P("					return nil, fmt.Errorf(\"", field.GoName, " must be an array of messages\")")
				g.P("				}")
			} else {
				g.P("				if msgVal, ok := val.(map[string]interface{}); ok {")
				g.P("					// Create a new instance of the nested message")
				g.P("					nestedMsg := &", field.Message.GoIdent, "{}")
				g.P("					// Convert nested message fields")
				g.P("					if err := convertParamsToMessage(msgVal, nestedMsg); err != nil {")
				g.P("						return nil, fmt.Errorf(\"failed to convert nested message ", field.GoName, ": %v\", err)")
				g.P("					}")
				g.P("					req.", field.GoName, " = nestedMsg")
				g.P("				} else {")
				g.P("					return nil, fmt.Errorf(\"", field.GoName, " must be a message\")")
				g.P("				}")
			}
		case protoreflect.EnumKind:
			if field.Desc.IsList() {
				g.P("				if arrVal, ok := val.([]interface{}); ok {")
				g.P("					req.", field.GoName, " = make([]", field.Enum.GoIdent, ", len(arrVal))")
				g.P("					for i, v := range arrVal {")
				g.P("						if strVal, ok := v.(string); ok {")
				g.P("							// Try to convert string to enum value")
				g.P("							if enumVal, ok := ", field.Enum.GoIdent, "_value[strVal]; ok {")
				g.P("								req.", field.GoName, "[i] = ", field.Enum.GoIdent, "(enumVal)")
				g.P("							} else {")
				g.P("								return nil, fmt.Errorf(\"invalid enum value for ", field.GoName, ": %s\", strVal)")
				g.P("							}")
				g.P("						} else if numVal, ok := v.(float64); ok {")
				g.P("							// Direct numeric value")
				g.P("							req.", field.GoName, "[i] = ", field.Enum.GoIdent, "(int32(numVal))")
				g.P("						} else {")
				g.P("							return nil, fmt.Errorf(\"", field.GoName, " must be an array of enum values\")")
				g.P("						}")
				g.P("					}")
				g.P("				} else {")
				g.P("					return nil, fmt.Errorf(\"", field.GoName, " must be an array of enum values\")")
				g.P("				}")
			} else {
				g.P("				if strVal, ok := val.(string); ok {")
				g.P("					// Try to convert string to enum value")
				g.P("					if enumVal, ok := ", field.Enum.GoIdent, "_value[strVal]; ok {")
				g.P("						req.", field.GoName, " = ", field.Enum.GoIdent, "(enumVal)")
				g.P("					} else {")
				g.P("						return nil, fmt.Errorf(\"invalid enum value for ", field.GoName, ": %s\", strVal)")
				g.P("					}")
				g.P("				} else if numVal, ok := val.(float64); ok {")
				g.P("					// Direct numeric value")
				g.P("					req.", field.GoName, " = ", field.Enum.GoIdent, "(int32(numVal))")
				g.P("				} else {")
				g.P("					return nil, fmt.Errorf(\"", field.GoName, " must be an enum value\")")
				g.P("				}")
			}
		}
		g.P("			}")
	}

	// Call the service method
	g.P()
	g.P("			// Call the service method")
	g.P("			resp, err := s.server.", method.GoName, "(ctx, req, grpc.StaticMethod())")
	g.P("			if err != nil {")
	g.P("				return nil, err")
	g.P("			}")
	g.P()

	// Convert response to MCP result
	g.P()
	g.P("			// Convert response to MCP result")
	g.P("			return mcp.NewToolResultText(fmt.Sprintf(\"%+v\", resp)), nil")
	g.P("		},")
	g.P("	})")
	g.P()

	return true, nil
}

func getTypeConversion(kind protoreflect.Kind, value string) string {
	switch kind {
	case protoreflect.Int32Kind:
		return "int32(" + value + ")"
	case protoreflect.Int64Kind:
		return "int64(" + value + ")"
	case protoreflect.Uint32Kind:
		return "uint32(" + value + ")"
	case protoreflect.Uint64Kind:
		return "uint64(" + value + ")"
	default:
		return value
	}
}

func getTypeName(kind protoreflect.Kind) string {
	switch kind {
	case protoreflect.Int32Kind:
		return "int32"
	case protoreflect.Int64Kind:
		return "int64"
	case protoreflect.Uint32Kind:
		return "uint32"
	case protoreflect.Uint64Kind:
		return "uint64"
	default:
		return "int32"
	}
}

func getMapValueType(field *protogen.Field, service *protogen.Service, importedPackages map[string]string) string {
	switch field.Desc.MapValue().Kind() {
	case protoreflect.StringKind:
		return "string"
	case protoreflect.Int32Kind:
		return "int32"
	case protoreflect.Int64Kind:
		return "int64"
	case protoreflect.Uint32Kind:
		return "uint32"
	case protoreflect.Uint64Kind:
		return "uint64"
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.BytesKind:
		return "[]byte"
	case protoreflect.MessageKind:
		// Get the message type from the map value
		mapValue := field.Desc.MapValue()
		// Get the message descriptor
		msgDesc := mapValue.Message()
		// Get the full name of the message
		fullProtoName := string(msgDesc.FullName())

		// Check if this is a well-known type
		if wellKnownType, ok := wellKnownTypes[fullProtoName]; ok {
			// Track the package for import
			importedPackages[wellKnownType.importPath] = wellKnownType.importPath
			return "*" + wellKnownType.pkgName + "." + string(msgDesc.Name())
		}

		// For regular protobuf messages, just return the name without package
		// The protogen package will handle the correct package name
		return "*" + string(msgDesc.Name())
	default:
		return "string"
	}
}

func getMapValueConversion(field *protogen.Field, valueVar, targetVar string, service *protogen.Service, currentPkg string, importedPackages map[string]string) string {
	switch field.Desc.MapValue().Kind() {
	case protoreflect.StringKind:
		return fmt.Sprintf("if strVal, ok := %s.(string); ok {\n\t\t\t\t%s = strVal\n\t\t\t} else {\n\t\t\t\treturn nil, fmt.Errorf(\"map value must be a string\")\n\t\t\t}", valueVar, targetVar)
	case protoreflect.Int32Kind:
		return fmt.Sprintf("if numVal, ok := %s.(float64); ok {\n\t\t\t\t%s = int32(numVal)\n\t\t\t} else {\n\t\t\t\treturn nil, fmt.Errorf(\"map value must be a number\")\n\t\t\t}", valueVar, targetVar)
	case protoreflect.Int64Kind:
		return fmt.Sprintf("if numVal, ok := %s.(float64); ok {\n\t\t\t\t%s = int64(numVal)\n\t\t\t} else {\n\t\t\t\treturn nil, fmt.Errorf(\"map value must be a number\")\n\t\t\t}", valueVar, targetVar)
	case protoreflect.Uint32Kind:
		return fmt.Sprintf("if numVal, ok := %s.(float64); ok {\n\t\t\t\t%s = uint32(numVal)\n\t\t\t} else {\n\t\t\t\treturn nil, fmt.Errorf(\"map value must be a number\")\n\t\t\t}", valueVar, targetVar)
	case protoreflect.Uint64Kind:
		return fmt.Sprintf("if numVal, ok := %s.(float64); ok {\n\t\t\t\t%s = uint64(numVal)\n\t\t\t} else {\n\t\t\t\treturn nil, fmt.Errorf(\"map value must be a number\")\n\t\t\t}", valueVar, targetVar)
	case protoreflect.BoolKind:
		return fmt.Sprintf("if boolVal, ok := %s.(bool); ok {\n\t\t\t\t%s = boolVal\n\t\t\t} else {\n\t\t\t\treturn nil, fmt.Errorf(\"map value must be a boolean\")\n\t\t\t}", valueVar, targetVar)
	case protoreflect.BytesKind:
		return fmt.Sprintf("if strVal, ok := %s.(string); ok {\n\t\t\t\t%s = []byte(strVal)\n\t\t\t} else {\n\t\t\t\treturn nil, fmt.Errorf(\"map value must be a string\")\n\t\t\t}", valueVar, targetVar)
	case protoreflect.MessageKind:
		// Get the message type from the map value
		mapValue := field.Desc.MapValue()
		// Get the message descriptor
		msgDesc := mapValue.Message()
		// Get the full name of the message
		fullProtoName := string(msgDesc.FullName())

		// Check if this is a well-known type
		if wellKnownType, ok := wellKnownTypes[fullProtoName]; ok {
			return fmt.Sprintf("if msgVal, ok := %s.(map[string]interface{}); ok {\n\t\t\t\t// Create a new instance of the nested message\n\t\t\t\tnestedMsg := %s.%s{}\n\t\t\t\t// Convert nested message fields\n\t\t\t\tif err := convertParamsToMessage(msgVal, nestedMsg); err != nil {\n\t\t\t\t\treturn nil, fmt.Errorf(\"failed to convert nested message in map: %%v\", err)\n\t\t\t\t}\n\t\t\t\t%s = nestedMsg\n\t\t\t} else {\n\t\t\t\treturn nil, fmt.Errorf(\"map value must be a message\")\n\t\t\t}", valueVar, wellKnownType.pkgName, string(msgDesc.Name()), targetVar)
		}

		// For regular protobuf messages, just return the name without package
		// The protogen package will handle the correct package name
		fullName := string(msgDesc.Name())
		if string(service.Desc.ParentFile().Package().Name()) != string(service.Desc.ParentFile().Package().Name()) {
			fullName = string(service.Desc.ParentFile().Package().Name()) + "." + string(msgDesc.Name())
		}
		return fmt.Sprintf("if msgVal, ok := %s.(map[string]interface{}); ok {\n\t\t\t\t// Create a new instance of the nested message\n\t\t\t\tnestedMsg := %s{}\n\t\t\t\t// Convert nested message fields\n\t\t\t\tif err := convertParamsToMessage(msgVal, nestedMsg); err != nil {\n\t\t\t\t\treturn nil, fmt.Errorf(\"failed to convert nested message in map: %%v\", err)\n\t\t\t\t}\n\t\t\t\t%s = nestedMsg\n\t\t\t} else {\n\t\t\t\treturn nil, fmt.Errorf(\"map value must be a message\")\n\t\t\t}", valueVar, fullName, targetVar)
	default:
		return fmt.Sprintf("if strVal, ok := %s.(string); ok {\n\t\t\t\t%s = strVal\n\t\t\t} else {\n\t\t\t\treturn nil, fmt.Errorf(\"map value must be a string\")\n\t\t\t}", valueVar, targetVar)
	}
}

func getPointerTypeName(msgDesc protoreflect.MessageDescriptor, currentPkg string, importedPackages map[string]string) string {
	// Get the full name of the message
	fullProtoName := string(msgDesc.FullName())

	// Well-known types
	if wellKnownType, ok := wellKnownTypes[fullProtoName]; ok {
		importedPackages[wellKnownType.importPath] = wellKnownType.importPath
		return "&" + wellKnownType.pkgName + "." + string(msgDesc.Name()) + "{}"
	}

	// For regular protobuf messages, just return the name without package
	// The protogen package will handle the correct package name
	return "&" + string(msgDesc.Name()) + "{}"
}

// generateMessageJSONTemplate generates a JSON template for a protobuf message
func generateMessageJSONTemplate(message *protogen.Message) string {
	return generateMessageJSONTemplateWithVisited(message, make(map[string]bool))
}

// generateMessageJSONTemplateWithVisited generates a JSON template for a protobuf message
// while tracking visited messages to prevent circular references
func generateMessageJSONTemplateWithVisited(message *protogen.Message, visited map[string]bool) string {
	// Check if we've already visited this message type to prevent circular references
	messageName := string(message.Desc.FullName())
	if visited[messageName] {
		return "{}" // Return empty object for circular references
	}
	visited[messageName] = true

	template := "{\n"
	for _, field := range message.Fields {
		fieldName := field.Desc.JSONName()
		switch field.Desc.Kind() {
		case protoreflect.StringKind:
			if field.Desc.IsList() {
				template += fmt.Sprintf("  \"%s\": [\"string\"],\n", fieldName)
			} else {
				template += fmt.Sprintf("  \"%s\": \"string\",\n", fieldName)
			}
		case protoreflect.BytesKind:
			if field.Desc.IsList() {
				template += fmt.Sprintf("  \"%s\": [\"base64\"],\n", fieldName)
			} else {
				template += fmt.Sprintf("  \"%s\": \"base64\",\n", fieldName)
			}
		case protoreflect.Int32Kind, protoreflect.Int64Kind,
			protoreflect.Uint32Kind, protoreflect.Uint64Kind:
			if field.Desc.IsList() {
				template += fmt.Sprintf("  \"%s\": [0],\n", fieldName)
			} else {
				template += fmt.Sprintf("  \"%s\": 0,\n", fieldName)
			}
		case protoreflect.BoolKind:
			if field.Desc.IsList() {
				template += fmt.Sprintf("  \"%s\": [false],\n", fieldName)
			} else {
				template += fmt.Sprintf("  \"%s\": false,\n", fieldName)
			}
		case protoreflect.MessageKind:
			if field.Desc.IsMap() {
				// For maps, we need to handle both key and value types
				keyType := "string" // protobuf map keys are always strings
				var valueTemplate string
				switch field.Desc.MapValue().Kind() {
				case protoreflect.StringKind:
					valueTemplate = "\"string\""
				case protoreflect.BytesKind:
					valueTemplate = "\"base64\""
				case protoreflect.Int32Kind, protoreflect.Int64Kind,
					protoreflect.Uint32Kind, protoreflect.Uint64Kind:
					valueTemplate = "0"
				case protoreflect.BoolKind:
					valueTemplate = "false"
				case protoreflect.MessageKind:
					// For nested message values in maps, we need to get the message type
					nestedMsg := field.Message
					if nestedMsg != nil {
						valueTemplate = generateMessageJSONTemplateWithVisited(nestedMsg, visited)
					} else {
						valueTemplate = "{}"
					}
				case protoreflect.EnumKind:
					valueTemplate = "\"ENUM_VALUE\""
				default:
					valueTemplate = "\"string\""
				}
				template += fmt.Sprintf("  \"%s\": {\"%s\": %s},\n", fieldName, keyType, valueTemplate)
			} else if field.Desc.IsList() {
				// For repeated messages, generate template for a single item
				nestedMsg := field.Message
				if nestedMsg != nil {
					nestedTemplate := generateMessageJSONTemplateWithVisited(nestedMsg, visited)
					template += fmt.Sprintf("  \"%s\": [%s],\n", fieldName, nestedTemplate)
				} else {
					template += fmt.Sprintf("  \"%s\": [{}],\n", fieldName)
				}
			} else {
				// For single message fields, generate the full template
				nestedMsg := field.Message
				if nestedMsg != nil {
					nestedTemplate := generateMessageJSONTemplateWithVisited(nestedMsg, visited)
					template += fmt.Sprintf("  \"%s\": %s,\n", fieldName, nestedTemplate)
				} else {
					template += fmt.Sprintf("  \"%s\": {},\n", fieldName)
				}
			}
		case protoreflect.EnumKind:
			if field.Desc.IsList() {
				template += fmt.Sprintf("  \"%s\": [\"ENUM_VALUE\"],\n", fieldName)
			} else {
				template += fmt.Sprintf("  \"%s\": \"ENUM_VALUE\",\n", fieldName)
			}
		}
	}
	template += "}"
	return template
}

// generateMessageJSONSchema generates a JSON schema for a protobuf message
func generateMessageJSONSchema(message *protogen.Message, visited map[string]bool) map[string]interface{} {
	// Check if we've already visited this message type to prevent circular references
	messageName := string(message.Desc.FullName())
	if visited[messageName] {
		return map[string]interface{}{
			"type": "object",
		} // Return simple object for circular references
	}
	visited[messageName] = true

	schema := map[string]interface{}{
		"type":       "object",
		"properties": make(map[string]interface{}),
	}

	requiredFields := make([]string, 0)

	for _, field := range message.Fields {
		fieldName := field.Desc.JSONName()
		fieldSchema := make(map[string]interface{})

		// Get MCP field annotations
		fieldDesc := proto.GetExtension(field.Desc.Options(), mcp.E_McpFieldDescription).(string)
		isRequired := proto.GetExtension(field.Desc.Options(), mcp.E_McpRequired).(bool)
		validationPattern := proto.GetExtension(field.Desc.Options(), mcp.E_McpValidationPattern).(string)

		// Add description if present
		if fieldDesc != "" {
			fieldSchema["description"] = fieldDesc
		}

		// Add validation pattern if present
		if validationPattern != "" {
			fieldSchema["pattern"] = validationPattern
		}

		switch field.Desc.Kind() {
		case protoreflect.StringKind:
			if field.Desc.IsList() {
				fieldSchema["type"] = "array"
				fieldSchema["items"] = map[string]interface{}{
					"type": "string",
				}
			} else {
				fieldSchema["type"] = "string"
			}
		case protoreflect.BytesKind:
			if field.Desc.IsList() {
				fieldSchema["type"] = "array"
				fieldSchema["items"] = map[string]interface{}{
					"type":   "string",
					"format": "byte",
				}
			} else {
				fieldSchema["type"] = "string"
				fieldSchema["format"] = "byte"
			}
		case protoreflect.Int32Kind, protoreflect.Int64Kind,
			protoreflect.Uint32Kind, protoreflect.Uint64Kind:
			if field.Desc.IsList() {
				fieldSchema["type"] = "array"
				fieldSchema["items"] = map[string]interface{}{
					"type": "number",
				}
			} else {
				fieldSchema["type"] = "number"
			}
		case protoreflect.BoolKind:
			if field.Desc.IsList() {
				fieldSchema["type"] = "array"
				fieldSchema["items"] = map[string]interface{}{
					"type": "boolean",
				}
			} else {
				fieldSchema["type"] = "boolean"
			}
		case protoreflect.MessageKind:
			if field.Desc.IsMap() {
				fieldSchema["type"] = "object"
				fieldSchema["additionalProperties"] = generateMessageJSONSchema(field.Message, visited)
			} else if field.Desc.IsList() {
				fieldSchema["type"] = "array"
				fieldSchema["items"] = generateMessageJSONSchema(field.Message, visited)
			} else {
				fieldSchema = generateMessageJSONSchema(field.Message, visited)
			}
		case protoreflect.EnumKind:
			if field.Desc.IsList() {
				fieldSchema["type"] = "array"
				fieldSchema["items"] = map[string]interface{}{
					"type": "string",
					"enum": getEnumValues(field.Enum),
				}
			} else {
				fieldSchema["type"] = "string"
				fieldSchema["enum"] = getEnumValues(field.Enum)
			}
		}

		schema["properties"].(map[string]interface{})[fieldName] = fieldSchema
		if isRequired {
			requiredFields = append(requiredFields, fieldName)
		}
	}

	if len(requiredFields) > 0 {
		schema["required"] = requiredFields
	}

	return schema
}

// getEnumValues returns a list of enum values as strings
func getEnumValues(enum *protogen.Enum) []string {
	values := make([]string, 0, len(enum.Values))
	for _, value := range enum.Values {
		values = append(values, string(value.Desc.Name()))
	}
	return values
}

// generateSchemaMapString converts a schema map to a Go map literal string
func generateSchemaMapString(schema map[string]interface{}) string {
	var result strings.Builder
	result.WriteString("map[string]interface{}{")
	
	// Sort keys for deterministic output
	keys := make([]string, 0, len(schema))
	for k := range schema {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for i, k := range keys {
		if i > 0 {
			result.WriteString(", ")
		}
		v := schema[k]
		result.WriteString(fmt.Sprintf("%q: ", k))
		
		switch val := v.(type) {
		case string:
			result.WriteString(fmt.Sprintf("%q", val))
		case bool:
			result.WriteString(fmt.Sprintf("%v", val))
		case float64:
			result.WriteString(fmt.Sprintf("%v", val))
		case []interface{}:
			result.WriteString(generateArrayString(val))
		case map[string]interface{}:
			result.WriteString(generateSchemaMapString(val))
		default:
			result.WriteString("nil")
		}
	}
	
	result.WriteString("}")
	return result.String()
}

// generateArrayString converts an array to a Go slice literal string
func generateArrayString(arr []interface{}) string {
	var result strings.Builder
	result.WriteString("[]interface{}{")
	
	for i, v := range arr {
		if i > 0 {
			result.WriteString(", ")
		}
		
		switch val := v.(type) {
		case string:
			result.WriteString(fmt.Sprintf("%q", val))
		case bool:
			result.WriteString(fmt.Sprintf("%v", val))
		case float64:
			result.WriteString(fmt.Sprintf("%v", val))
		case []interface{}:
			result.WriteString(generateArrayString(val))
		case map[string]interface{}:
			result.WriteString(generateSchemaMapString(val))
		default:
			result.WriteString("nil")
		}
	}
	
	result.WriteString("}")
	return result.String()
}

// generateEnumValuesString converts enum values to a Go slice literal string
func generateEnumValuesString(enum *protogen.Enum) string {
	values := getEnumValues(enum)
	var result strings.Builder
	result.WriteString("[]string{")
	
	for i, v := range values {
		if i > 0 {
			result.WriteString(", ")
		}
		result.WriteString(fmt.Sprintf("%q", v))
	}
	
	result.WriteString("}")
	return result.String()
}
