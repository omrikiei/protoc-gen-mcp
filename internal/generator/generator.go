package generator

import (
	"github.com/omrikiei/protoc-gen-mcp/internal/protogen/mcp"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

// GenerateFile generates the MCP server, client, and mock server code for a proto file.
func GenerateFile(gen *protogen.Plugin, file *protogen.File) error {
	if len(file.Services) == 0 {
		return nil
	}

	// Generate the MCP server package
	mcpFilename := file.GeneratedFilenamePrefix + "_mcp/mcp.pb.go"
	mcpImportPath := protogen.GoImportPath(file.GoImportPath.String() + "_mcp")
	mcpG := gen.NewGeneratedFile(mcpFilename, mcpImportPath)

	// Add all imports using QualifiedGoIdent
	mcpG.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "bufio",
		GoImportPath: "bufio",
	})
	mcpG.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "context",
		GoImportPath: "context",
	})
	mcpG.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "json",
		GoImportPath: "encoding/json",
	})
	mcpG.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "fmt",
		GoImportPath: "fmt",
	})
	mcpG.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "io",
		GoImportPath: "io",
	})
	mcpG.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "net/http",
		GoImportPath: "net/http",
	})
	mcpG.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "os",
		GoImportPath: "os",
	})
	mcpG.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "strings",
		GoImportPath: "strings",
	})
	mcpG.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "uuid",
		GoImportPath: "github.com/google/uuid",
	})
	mcpG.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "websocket",
		GoImportPath: "github.com/gorilla/websocket",
	})
	mcpG.Import("google.golang.org/grpc")

	// Generate header for MCP package
	mcpG.P("// Code generated by protoc-gen-mcp. DO NOT EDIT.")
	mcpG.P("// source: ", file.Desc.Path())
	mcpG.P()
	mcpG.P("package ", file.GoPackageName+"_mcp")
	mcpG.P()

	// Generate MCP protocol types
	mcpG.P("// MCPRequest represents an MCP protocol request")
	mcpG.P("type MCPRequest struct {")
	mcpG.P("	Method string          `json:\"method\"`")
	mcpG.P("	Params json.RawMessage `json:\"params,omitempty\"`")
	mcpG.P("	ID     interface{}     `json:\"id\"`")
	mcpG.P("}")
	mcpG.P()

	mcpG.P("// MCPResponse represents an MCP protocol response")
	mcpG.P("type MCPResponse struct {")
	mcpG.P("	Result interface{} `json:\"result,omitempty\"`")
	mcpG.P("	Error  *MCPError  `json:\"error,omitempty\"`")
	mcpG.P("	ID     interface{} `json:\"id\"`")
	mcpG.P("}")
	mcpG.P()

	mcpG.P("// MCPError represents an MCP protocol error")
	mcpG.P("type MCPError struct {")
	mcpG.P("	Code    int         `json:\"code\"`")
	mcpG.P("	Message string      `json:\"message\"`")
	mcpG.P("	Data    interface{} `json:\"data,omitempty\"`")
	mcpG.P("}")
	mcpG.P()

	mcpG.P("// MCPNotification represents an MCP protocol notification")
	mcpG.P("type MCPNotification struct {")
	mcpG.P("	Method string          `json:\"method\"`")
	mcpG.P("	Params json.RawMessage `json:\"params,omitempty\"`")
	mcpG.P("}")
	mcpG.P()

	// Generate MCP server interface
	mcpG.P("// MCPServer represents an MCP protocol server")
	mcpG.P("type MCPServer struct {")
	mcpG.P("	name         string")
	mcpG.P("	version      string")
	mcpG.P("	capabilities map[string]interface{}")
	mcpG.P("	handlers     map[string]func(context.Context, json.RawMessage) (interface{}, error)")
	mcpG.P("	resources    []Resource")
	mcpG.P("	templates    []ResourceTemplate")
	mcpG.P("	auth         AuthConfig")
	mcpG.P("	upgrader     websocket.Upgrader")
	mcpG.P("}")
	mcpG.P()

	// Generate MCP server constructor
	mcpG.P("// NewMCPServer creates a new MCP server")
	mcpG.P("func NewMCPServer(name, version string, auth AuthConfig) *MCPServer {")
	mcpG.P("	return &MCPServer{")
	mcpG.P("		name:        name,")
	mcpG.P("		version:     version,")
	mcpG.P("		handlers:    make(map[string]func(context.Context, json.RawMessage) (interface{}, error)),")
	mcpG.P("		resources:   make([]Resource, 0),")
	mcpG.P("		templates:   make([]ResourceTemplate, 0),")
	mcpG.P("		auth:        auth,")
	mcpG.P("		upgrader: websocket.Upgrader{")
	mcpG.P("			ReadBufferSize:  1024,")
	mcpG.P("			WriteBufferSize: 1024,")
	mcpG.P("			CheckOrigin: func(r *http.Request) bool {")
	mcpG.P("				// Implement proper origin checking")
	mcpG.P("				return true")
	mcpG.P("			},")
	mcpG.P("		},")
	mcpG.P("	}")
	mcpG.P("}")
	mcpG.P()

	// Generate initialization handler
	mcpG.P("func (s *MCPServer) handleInitialize(ctx context.Context, params json.RawMessage) (interface{}, error) {")
	mcpG.P("	return map[string]interface{}{")
	mcpG.P("		\"serverInfo\": map[string]interface{}{")
	mcpG.P("			\"name\":    s.name,")
	mcpG.P("			\"version\": s.version,")
	mcpG.P("		},")
	mcpG.P("		\"capabilities\": map[string]interface{}{")
	mcpG.P("			\"resources\": map[string]interface{}{")
	mcpG.P("				\"templates\":  true,")
	mcpG.P("				\"progress\":   true,")
	mcpG.P("				\"streaming\":  true,")
	mcpG.P("				\"binary\":     true,")
	mcpG.P("			},")
	mcpG.P("			\"security\": map[string]interface{}{")
	mcpG.P("				\"authentication\": s.auth,")
	mcpG.P("			},")
	mcpG.P("		},")
	mcpG.P("	}, nil")
	mcpG.P("}")
	mcpG.P()

	// Generate WebSocket handler
	mcpG.P("func (s *MCPServer) ServeWS(w http.ResponseWriter, r *http.Request) {")
	mcpG.P("	conn, err := s.upgrader.Upgrade(w, r, nil)")
	mcpG.P("	if err != nil {")
	mcpG.P("		http.Error(w, \"Could not upgrade connection\", http.StatusInternalServerError)")
	mcpG.P("		return")
	mcpG.P("	}")
	mcpG.P("	defer conn.Close()")
	mcpG.P()

	mcpG.P("	for {")
	mcpG.P("		var req MCPRequest")
	mcpG.P("		err := conn.ReadJSON(&req)")
	mcpG.P("		if err != nil {")
	mcpG.P("			if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {")
	mcpG.P("				// Handle unexpected close")
	mcpG.P("			}")
	mcpG.P("			break")
	mcpG.P("		}")
	mcpG.P()

	mcpG.P("		handler, ok := s.handlers[req.Method]")
	mcpG.P("		if !ok {")
	mcpG.P("			conn.WriteJSON(MCPResponse{")
	mcpG.P("				Error: &MCPError{")
	mcpG.P("					Code:    -32601,")
	mcpG.P("					Message: \"Method not found\",")
	mcpG.P("				},")
	mcpG.P("				ID: req.ID,")
	mcpG.P("			})")
	mcpG.P("			continue")
	mcpG.P("		}")
	mcpG.P()

	mcpG.P("		result, err := handler(r.Context(), req.Params)")
	mcpG.P("		if err != nil {")
	mcpG.P("			conn.WriteJSON(MCPResponse{")
	mcpG.P("				Error: &MCPError{")
	mcpG.P("					Code:    -32603,")
	mcpG.P("					Message: err.Error(),")
	mcpG.P("				},")
	mcpG.P("				ID: req.ID,")
	mcpG.P("			})")
	mcpG.P("			continue")
	mcpG.P("		}")
	mcpG.P()

	mcpG.P("		conn.WriteJSON(MCPResponse{")
	mcpG.P("			Result: result,")
	mcpG.P("			ID:     req.ID,")
	mcpG.P("		})")
	mcpG.P("	}")
	mcpG.P("}")
	mcpG.P()

	// Generate utility functions for path and query parameter handling
	mcpG.P("// ParsePathParams extracts path parameters from the request URL.")
	mcpG.P("func ParsePathParams(pattern, path string) (map[string]string, error) {")
	mcpG.P("	patternParts := strings.Split(pattern, \"/\")")
	mcpG.P("	pathParts := strings.Split(path, \"/\")")
	mcpG.P()

	mcpG.P("	if len(patternParts) != len(pathParts) {")
	mcpG.P("		return nil, fmt.Errorf(\"path length mismatch\")")
	mcpG.P("	}")
	mcpG.P()

	mcpG.P("	params := make(map[string]string)")
	mcpG.P("	for i, part := range patternParts {")
	mcpG.P("		if strings.HasPrefix(part, \"{\") && strings.HasSuffix(part, \"}\") {")
	mcpG.P("			paramName := part[1 : len(part)-1]")
	mcpG.P("			params[paramName] = pathParts[i]")
	mcpG.P("		}")
	mcpG.P("	}")
	mcpG.P("	return params, nil")
	mcpG.P("}")
	mcpG.P()

	mcpG.P("// ApplyPathParams sets path parameters in the request message.")
	mcpG.P("func ApplyPathParams(req interface{}, params map[string]string) error {")
	mcpG.P("	// This is a simplified implementation that assumes the request struct")
	mcpG.P("	// has fields matching the parameter names.")
	mcpG.P("	// In a real implementation, you would use reflection to set the fields.")
	mcpG.P("	return nil")
	mcpG.P("}")
	mcpG.P()

	mcpG.P("// ApplyQueryParams sets query parameters in the request message.")
	mcpG.P("func ApplyQueryParams(req interface{}, params map[string][]string) error {")
	mcpG.P("	// This is a simplified implementation that assumes the request struct")
	mcpG.P("	// has fields matching the parameter names.")
	mcpG.P("	// In a real implementation, you would use reflection to set the fields.")
	mcpG.P("	return nil")
	mcpG.P("}")
	mcpG.P()

	// Generate stdio transport
	mcpG.P("// StdioTransport implements MCP transport over stdin/stdout")
	mcpG.P("type StdioTransport struct {")
	mcpG.P("	reader * bufio.Reader")
	mcpG.P("	writer * bufio.Writer")
	mcpG.P("}")
	mcpG.P()

	mcpG.P("// NewStdioTransport creates a new stdio transport")
	mcpG.P("func NewStdioTransport() *StdioTransport {")
	mcpG.P("	return &StdioTransport{")
	mcpG.P("		reader: bufio.NewReader(os.Stdin),")
	mcpG.P("		writer: bufio.NewWriter(os.Stdout),")
	mcpG.P("	}")
	mcpG.P("}")
	mcpG.P()

	mcpG.P("func (t *StdioTransport) Read() ([]byte, error) {")
	mcpG.P("	return t.reader.ReadBytes('\\n')")
	mcpG.P("}")
	mcpG.P()

	mcpG.P("func (t *StdioTransport) Write(data []byte) error {")
	mcpG.P("	_, err := t.writer.Write(append(data, '\\n'))")
	mcpG.P("	if err != nil {")
	mcpG.P("		return err")
	mcpG.P("	}")
	mcpG.P("	return t.writer.Flush()")
	mcpG.P("}")
	mcpG.P()

	// Generate resource types
	mcpG.P("// Resource represents an MCP resource")
	mcpG.P("type Resource struct {")
	mcpG.P("	URI         string `json:\"uri\"`")
	mcpG.P("	Name        string `json:\"name\"`")
	mcpG.P("	Description string `json:\"description,omitempty\"`")
	mcpG.P("	MimeType    string `json:\"mimeType,omitempty\"`")
	mcpG.P("}")
	mcpG.P()

	mcpG.P("// ResourceContent represents the content of an MCP resource")
	mcpG.P("type ResourceContent struct {")
	mcpG.P("	URI      string `json:\"uri\"`")
	mcpG.P("	MimeType string `json:\"mimeType,omitempty\"`")
	mcpG.P("	Text     string `json:\"text,omitempty\"`")
	mcpG.P("	Binary   []byte `json:\"binary,omitempty\"`")
	mcpG.P("}")
	mcpG.P()

	// Add resource handlers to MCPServer
	mcpG.P("func (s *MCPServer) handleListResources(ctx context.Context, params json.RawMessage) (interface{}, error) {")
	mcpG.P("	return map[string]interface{}{")
	mcpG.P("		\"resources\": s.resources,")
	mcpG.P("		\"templates\": s.templates,")
	mcpG.P("	}, nil")
	mcpG.P("}")
	mcpG.P()

	mcpG.P("func (s *MCPServer) handleReadResource(ctx context.Context, params json.RawMessage) (interface{}, error) {")
	mcpG.P("	var req struct {")
	mcpG.P("		URI string `json:\"uri\"`")
	mcpG.P("	}")
	mcpG.P("	if err := json.Unmarshal(params, &req); err != nil {")
	mcpG.P("		return nil, err")
	mcpG.P("	}")
	mcpG.P()
	mcpG.P("	// Create progress token")
	mcpG.P("	token := uuid.New().String()")
	mcpG.P("	progress := Progress{")
	mcpG.P("		Token:   token,")
	mcpG.P("		Message: \"Reading resource\",")
	mcpG.P("	}")
	mcpG.P()
	mcpG.P("	// Send initial progress")
	mcpG.P("	if transport, ok := ctx.Value(\"transport\").(*SSETransport); ok {")
	mcpG.P("		transport.Send(\"progress\", progress)")
	mcpG.P("	}")
	mcpG.P()
	mcpG.P("	// Implement resource reading logic")
	mcpG.P("	content := ResourceContent{")
	mcpG.P("		URI: req.URI,")
	mcpG.P("	}")
	mcpG.P()
	mcpG.P("	// Update progress")
	mcpG.P("	progress.Percent = 100")
	mcpG.P("	if transport, ok := ctx.Value(\"transport\").(*SSETransport); ok {")
	mcpG.P("		transport.Send(\"progress\", progress)")
	mcpG.P("	}")
	mcpG.P()
	mcpG.P("	return map[string]interface{}{")
	mcpG.P("		\"contents\": []ResourceContent{content},")
	mcpG.P("	}, nil")
	mcpG.P("}")
	mcpG.P()

	// Generate SSE transport
	mcpG.P("// SSETransport implements MCP transport over Server-Sent Events")
	mcpG.P("type SSETransport struct {")
	mcpG.P("	flusher http.Flusher")
	mcpG.P("	writer  http.ResponseWriter")
	mcpG.P("}")
	mcpG.P()

	mcpG.P("func NewSSETransport(w http.ResponseWriter) (*SSETransport, error) {")
	mcpG.P("	flusher, ok := w.(http.Flusher)")
	mcpG.P("	if !ok {")
	mcpG.P("		return nil, fmt.Errorf(\"streaming not supported\")")
	mcpG.P("	}")
	mcpG.P("	w.Header().Set(\"Content-Type\", \"text/event-stream\")")
	mcpG.P("	w.Header().Set(\"Cache-Control\", \"no-cache\")")
	mcpG.P("	w.Header().Set(\"Connection\", \"keep-alive\")")
	mcpG.P("	return &SSETransport{")
	mcpG.P("		flusher: flusher,")
	mcpG.P("		writer:  w,")
	mcpG.P("	}, nil")
	mcpG.P("}")
	mcpG.P()

	mcpG.P("func (t *SSETransport) Send(event string, data interface{}) error {")
	mcpG.P("	jsonData, err := json.Marshal(data)")
	mcpG.P("	if err != nil {")
	mcpG.P("		return err")
	mcpG.P("	}")
	mcpG.P("	fmt.Fprintf(t.writer, \"event: %s\\ndata: %s\\n\\n\", event, jsonData)")
	mcpG.P("	t.flusher.Flush()")
	mcpG.P("	return nil")
	mcpG.P("}")
	mcpG.P()

	// Add resource template support
	mcpG.P("// ResourceTemplate represents an MCP resource template")
	mcpG.P("type ResourceTemplate struct {")
	mcpG.P("	URITemplate string `json:\"uriTemplate\"`")
	mcpG.P("	Name        string `json:\"name\"`")
	mcpG.P("	Description string `json:\"description,omitempty\"`")
	mcpG.P("	MimeType    string `json:\"mimeType,omitempty\"`")
	mcpG.P("}")
	mcpG.P()

	// Add progress reporting
	mcpG.P("// Progress represents an MCP progress update")
	mcpG.P("type Progress struct {")
	mcpG.P("	Token    string  `json:\"token\"`")
	mcpG.P("	Message  string  `json:\"message,omitempty\"`")
	mcpG.P("	Current  int64   `json:\"current,omitempty\"`")
	mcpG.P("	Total    int64   `json:\"total,omitempty\"`")
	mcpG.P("	Percent  float64 `json:\"percent,omitempty\"`")
	mcpG.P("}")
	mcpG.P()

	// Add security types
	mcpG.P("// AuthConfig represents MCP authentication configuration")
	mcpG.P("type AuthConfig struct {")
	mcpG.P("	Required      bool     `json:\"required\"`")
	mcpG.P("	Methods       []string `json:\"methods\"`")
	mcpG.P("	TokenHeader   string   `json:\"tokenHeader,omitempty\"`")
	mcpG.P("	TokenType     string   `json:\"tokenType,omitempty\"`")
	mcpG.P("}")
	mcpG.P()

	// Register standard handlers in constructor
	mcpG.P("func init() {")
	mcpG.P("	s := NewMCPServer(\"mcp-server\", \"1.0.0\", AuthConfig{})")
	mcpG.P("	s.handlers[\"initialize\"] = s.handleInitialize")
	mcpG.P("	s.handlers[\"resources/list\"] = s.handleListResources")
	mcpG.P("	s.handlers[\"resources/read\"] = s.handleReadResource")
	mcpG.P("}")
	mcpG.P()

	// Generate code for each service
	for _, service := range file.Services {
		if err := generateService(mcpG, service, file); err != nil {
			return err
		}
	}

	return nil
}

func generateService(mcpG *protogen.GeneratedFile, service *protogen.Service, file *protogen.File) error {
	// Check if this is an MCP service
	isMCPService := proto.GetExtension(service.Desc.Options(), mcp.E_McpService).(bool)
	if !isMCPService {
		return nil
	}

	// Get MCP service options
	mcpVersion := proto.GetExtension(service.Desc.Options(), mcp.E_McpVersion).(string)
	mcpType := proto.GetExtension(service.Desc.Options(), mcp.E_McpType).(string)

	// Generate server interface
	mcpG.P("// ", service.GoName, "Server is the MCP server API for ", service.GoName, " service.")
	mcpG.P("type ", service.GoName, "Server interface {")
	for _, method := range service.Methods {
		mcpG.P(method.GoName, "(context.Context, *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error)")
	}
	mcpG.P("}")
	mcpG.P()

	// Generate MCP server implementation
	mcpG.P("// ", service.GoName, "MCPServer implements the MCP server for ", service.GoName, " service.")
	mcpG.P("type ", service.GoName, "MCPServer struct {")
	mcpG.P("	server ", service.GoName, "Server")
	mcpG.P("	version string")
	mcpG.P("	serviceType string")
	mcpG.P("}")
	mcpG.P()

	// Generate MCP server constructor
	mcpG.P("// New", service.GoName, "MCPServer creates a new MCP server for ", service.GoName, " service.")
	mcpG.P("func New", service.GoName, "MCPServer(server ", service.GoName, "Server) *", service.GoName, "MCPServer {")
	mcpG.P("	return &", service.GoName, "MCPServer{")
	mcpG.P("		server: server,")
	mcpG.P("		version: \"", mcpVersion, "\",")
	mcpG.P("		serviceType: \"", mcpType, "\",")
	mcpG.P("	}")
	mcpG.P("}")
	mcpG.P()

	// Generate MCP server methods
	for _, method := range service.Methods {
		if err := generateMCPServerMethod(mcpG, service, method); err != nil {
			return err
		}
	}

	// Generate HTTP handler registration
	mcpG.P("// RegisterHTTPHandlers registers the HTTP handlers for the MCP server.")
	mcpG.P("func (s *", service.GoName, "MCPServer) RegisterHTTPHandlers(mux *http.ServeMux) {")
	for _, method := range service.Methods {
		isMCPMethod := proto.GetExtension(method.Desc.Options(), mcp.E_McpMethod).(bool)
		if !isMCPMethod {
			continue
		}
		path := proto.GetExtension(method.Desc.Options(), mcp.E_McpPath).(string)
		mcpG.P("	mux.HandleFunc(\"", path, "\", s.Handle", method.GoName, ")")
	}
	mcpG.P("}")
	mcpG.P()

	// Generate client interface
	mcpG.P("// ", service.GoName, "Client is the MCP client API for ", service.GoName, " service.")
	mcpG.P("type ", service.GoName, "Client interface {")
	for _, method := range service.Methods {
		mcpG.P(method.GoName, "(context.Context, *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error)")
	}
	mcpG.P("}")
	mcpG.P()

	// Generate MCP client implementation
	mcpG.P("// ", service.GoName, "MCPClient implements the MCP client for ", service.GoName, " service.")
	mcpG.P("type ", service.GoName, "MCPClient struct {")
	mcpG.P("	client *http.Client")
	mcpG.P("	baseURL string")
	mcpG.P("	version string")
	mcpG.P("	serviceType string")
	mcpG.P("}")
	mcpG.P()

	// Generate MCP client constructor
	mcpG.P("// New", service.GoName, "MCPClient creates a new MCP client for ", service.GoName, " service.")
	mcpG.P("func New", service.GoName, "MCPClient(baseURL string) *", service.GoName, "MCPClient {")
	mcpG.P("	return &", service.GoName, "MCPClient{")
	mcpG.P("		client: &http.Client{},")
	mcpG.P("		baseURL: strings.TrimSuffix(baseURL, \"/\"),")
	mcpG.P("		version: \"", mcpVersion, "\",")
	mcpG.P("		serviceType: \"", mcpType, "\",")
	mcpG.P("	}")
	mcpG.P("}")
	mcpG.P()

	// Generate MCP client methods
	for _, method := range service.Methods {
		if err := generateMCPClientMethod(mcpG, service, method); err != nil {
			return err
		}
	}

	// Generate GRPC server implementation
	mcpG.P("// ", service.GoName, "GRPCServer implements the MCP server using GRPC client.")
	mcpG.P("type ", service.GoName, "GRPCServer struct {")
	mcpG.P("	client ", service.GoName, "Client")
	mcpG.P("}")
	mcpG.P()

	mcpG.P("// New", service.GoName, "GRPCServer creates a new MCP server that uses GRPC client.")
	mcpG.P("func New", service.GoName, "GRPCServer(client ", service.GoName, "Client) *", service.GoName, "GRPCServer {")
	mcpG.P("	return &", service.GoName, "GRPCServer{")
	mcpG.P("		client: client,")
	mcpG.P("	}")
	mcpG.P("}")
	mcpG.P()

	// Generate method implementations
	for _, method := range service.Methods {
		mcpG.P("func (s *", service.GoName, "GRPCServer) ", method.GoName, "(ctx context.Context, req *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error) {")
		mcpG.P("	// Validate context")
		mcpG.P("	if ctx == nil {")
		mcpG.P("		return nil, fmt.Errorf(\"context cannot be nil\")")
		mcpG.P("	}")
		mcpG.P()
		mcpG.P("	// Validate request")
		mcpG.P("	if req == nil {")
		mcpG.P("		return nil, fmt.Errorf(\"request cannot be nil\")")
		mcpG.P("	}")
		mcpG.P()
		mcpG.P("	// Validate client")
		mcpG.P("	if s.client == nil {")
		mcpG.P("		return nil, fmt.Errorf(\"GRPC client not initialized\")")
		mcpG.P("	}")
		mcpG.P()
		mcpG.P("	// Call GRPC client")
		mcpG.P("	return s.client.", method.GoName, "(ctx, req)")
		mcpG.P("}")
		mcpG.P()
	}

	return nil
}

func generateMCPServerMethod(g *protogen.GeneratedFile, service *protogen.Service, method *protogen.Method) error {
	// Check if this is an MCP method
	isMCPMethod := proto.GetExtension(method.Desc.Options(), mcp.E_McpMethod).(bool)
	if !isMCPMethod {
		return nil
	}

	// Get MCP method options
	httpMethod := proto.GetExtension(method.Desc.Options(), mcp.E_McpHttpMethod).(string)
	path := proto.GetExtension(method.Desc.Options(), mcp.E_McpPath).(string)

	g.P("// Handle", method.GoName, " handles the MCP request for ", method.GoName, " method.")
	g.P("func (s *", service.GoName, "MCPServer) Handle", method.GoName, "(w http.ResponseWriter, r *http.Request) {")
	g.P("	if r.Method != \"", httpMethod, "\" {")
	g.P("		http.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)")
	g.P("		return")
	g.P("	}")
	g.P()

	// Parse path parameters
	g.P("	pathParams, err := ParsePathParams(\"", path, "\", r.URL.Path)")
	g.P("	if err != nil {")
	g.P("		http.Error(w, \"Invalid path parameters\", http.StatusBadRequest)")
	g.P("		return")
	g.P("	}")
	g.P()

	// Parse query parameters
	g.P("	queryParams := r.URL.Query()")
	g.P()

	// Parse request body
	g.P("	body, err := io.ReadAll(r.Body)")
	g.P("	if err != nil {")
	g.P("		http.Error(w, \"Failed to read request body\", http.StatusBadRequest)")
	g.P("		return")
	g.P("	}")
	g.P()

	// Create request message
	g.P("	req := &", method.Input.GoIdent, "{}")
	g.P("	if err := json.Unmarshal(body, req); err != nil {")
	g.P("		http.Error(w, \"Failed to parse request body\", http.StatusBadRequest)")
	g.P("		return")
	g.P("	}")
	g.P()

	// Apply path parameters to request
	g.P("	if err := ApplyPathParams(req, pathParams); err != nil {")
	g.P("		http.Error(w, \"Failed to apply path parameters\", http.StatusBadRequest)")
	g.P("		return")
	g.P("	}")
	g.P()

	// Apply query parameters to request
	g.P("	if err := ApplyQueryParams(req, queryParams); err != nil {")
	g.P("		http.Error(w, \"Failed to apply query parameters\", http.StatusBadRequest)")
	g.P("		return")
	g.P("	}")
	g.P()

	// Call the service method
	g.P("	resp, err := s.server.", method.GoName, "(r.Context(), req)")
	g.P("	if err != nil {")
	g.P("		http.Error(w, err.Error(), http.StatusInternalServerError)")
	g.P("		return")
	g.P("	}")
	g.P()

	// Write response
	g.P("	w.Header().Set(\"Content-Type\", \"application/json\")")
	g.P("	if err := json.NewEncoder(w).Encode(resp); err != nil {")
	g.P("		http.Error(w, \"Failed to encode response\", http.StatusInternalServerError)")
	g.P("		return")
	g.P("	}")
	g.P("}")
	g.P()

	return nil
}

func generateMCPClientMethod(g *protogen.GeneratedFile, service *protogen.Service, method *protogen.Method) error {
	// Check if this is an MCP method
	isMCPMethod := proto.GetExtension(method.Desc.Options(), mcp.E_McpMethod).(bool)
	if !isMCPMethod {
		return nil
	}

	// Get MCP method options
	httpMethod := proto.GetExtension(method.Desc.Options(), mcp.E_McpHttpMethod).(string)
	path := proto.GetExtension(method.Desc.Options(), mcp.E_McpPath).(string)

	g.P("// ", method.GoName, " sends a request to the ", method.GoName, " method.")
	g.P("func (c *", service.GoName, "MCPClient) ", method.GoName, "(ctx context.Context, req *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error) {")
	g.P("	// Create request body")
	g.P("	body, err := json.Marshal(req)")
	g.P("	if err != nil {")
	g.P("		return nil, fmt.Errorf(\"failed to marshal request: %w\", err)")
	g.P("	}")
	g.P()

	// Create HTTP request
	g.P("	url := fmt.Sprintf(\"%s%s\", c.baseURL, \"", path, "\")")
	g.P("	httpReq, err := http.NewRequestWithContext(ctx, \"", httpMethod, "\", url, strings.NewReader(string(body)))")
	g.P("	if err != nil {")
	g.P("		return nil, fmt.Errorf(\"failed to create request: %w\", err)")
	g.P("	}")
	g.P()

	// Set headers
	g.P("	httpReq.Header.Set(\"Content-Type\", \"application/json\")")
	g.P("	httpReq.Header.Set(\"X-MCP-Version\", c.version)")
	g.P("	httpReq.Header.Set(\"X-MCP-Type\", c.serviceType)")
	g.P()

	// Send request
	g.P("	resp, err := c.client.Do(httpReq)")
	g.P("	if err != nil {")
	g.P("		return nil, fmt.Errorf(\"failed to send request: %w\", err)")
	g.P("	}")
	g.P("	defer resp.Body.Close()")
	g.P()

	// Read response body
	g.P("	respBody, err := io.ReadAll(resp.Body)")
	g.P("	if err != nil {")
	g.P("		return nil, fmt.Errorf(\"failed to read response: %w\", err)")
	g.P("	}")
	g.P()

	// Check status code
	g.P("	if resp.StatusCode != http.StatusOK {")
	g.P("		return nil, fmt.Errorf(\"unexpected status code: %d, body: %s\", resp.StatusCode, string(respBody))")
	g.P("	}")
	g.P()

	// Parse response
	g.P("	var result ", method.Output.GoIdent)
	g.P("	if err := json.Unmarshal(respBody, &result); err != nil {")
	g.P("		return nil, fmt.Errorf(\"failed to parse response: %w\", err)")
	g.P("	}")
	g.P()

	g.P("	return &result, nil")
	g.P("}")
	g.P()

	return nil
}
