package generator

import (
	"fmt"

	"github.com/omrikiei/protoc-gen-mcp/protogen/mcp"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
)

// GenerateFile generates the MCP server code for a proto file.
func GenerateFile(gen *protogen.Plugin, file *protogen.File) error {
	if len(file.Services) == 0 {
		return nil
	}

	// Check if any service has MCP annotations
	hasMCPService := false
	for _, service := range file.Services {
		if version, ok := proto.GetExtension(service.Desc.Options(), mcp.E_McpVersion).(string); ok && version != "" {
			hasMCPService = true
			break
		}
	}
	if !hasMCPService {
		return nil
	}

	// Generate the MCP server package
	mcpFilename := file.GeneratedFilenamePrefix + ".mcp.pb.go"
	mcpG := gen.NewGeneratedFile(mcpFilename, file.GoImportPath)

	// Add imports
	mcpG.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "context",
		GoImportPath: "context",
	})
	mcpG.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "fmt",
		GoImportPath: "fmt",
	})
	mcpG.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "reflect",
		GoImportPath: "reflect",
	})
	mcpG.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "strings",
		GoImportPath: "strings",
	})
	mcpG.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "mcp",
		GoImportPath: "github.com/mark3labs/mcp-go/mcp",
	})
	mcpG.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "server",
		GoImportPath: "github.com/mark3labs/mcp-go/server",
	})
	mcpG.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "protojson",
		GoImportPath: "google.golang.org/protobuf/encoding/protojson",
	})

	// Generate header
	mcpG.P("// Code generated by protoc-gen-mcp. DO NOT EDIT.")
	mcpG.P("// source: ", file.Desc.Path())
	mcpG.P()
	mcpG.P("package ", file.GoPackageName)
	mcpG.P()

	// Generate code for each service
	for _, service := range file.Services {
		if err := generateService(mcpG, service, file); err != nil {
			return err
		}
	}

	return nil
}

func generateService(g *protogen.GeneratedFile, service *protogen.Service, file *protogen.File) error {
	// Check if this is an MCP service by looking for mcp_version
	mcpVersion, ok := proto.GetExtension(service.Desc.Options(), mcp.E_McpVersion).(string)
	if !ok || mcpVersion == "" {
		return nil
	}

	// Generate server interface
	g.P("// ", service.GoName, "MCPServer is the MCP server API for ", service.GoName, " service.")
	g.P("type ", service.GoName, "MCPServer interface {")
	for _, method := range service.Methods {
		g.P(method.GoName, "(context.Context, *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error)")
	}
	g.P("}")
	g.P()

	// Generate MCP server implementation
	g.P("// ", service.GoName, "MCPServerImpl implements the MCP server for ", service.GoName, " service.")
	g.P("type ", service.GoName, "MCPServerImpl struct {")
	g.P("	server ", service.GoName, "MCPServer")
	g.P("	MCPServer *server.MCPServer")
	g.P("}")
	g.P()

	// Generate MCP server constructor
	g.P("// New", service.GoName, "MCPServer creates a new MCP server for ", service.GoName, " service.")
	g.P("func New", service.GoName, "MCPServer(srv ", service.GoName, "MCPServer) *", service.GoName, "MCPServerImpl {")
	g.P("	s := &", service.GoName, "MCPServerImpl{")
	g.P("		server: srv,")
	g.P("		MCPServer: server.NewMCPServer(")
	g.P("			\"", service.GoName, "\",")
	g.P("			\"", mcpVersion, "\",")
	g.P("		),")
	g.P("	}")
	g.P()
	g.P("	// Register resources for request and response messages")
	for _, method := range service.Methods {
		// Register input message as resource
		g.P("	// Register ", method.Input.GoIdent, " as resource")
		g.P("	s.MCPServer.AddResource(mcp.Resource{")
		g.P("		URI: \"", method.Input.GoIdent, "\",")
		g.P("		Name: \"", method.Input.GoIdent, "\",")
		g.P("		Description: \"Request message for ", method.GoName, " method\",")
		g.P("		MIMEType: \"application/json\",")
		g.P("	}, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {")
		g.P("		// Create a new instance of the request message")
		g.P("		req := &", method.Input.GoIdent, "{}")
		g.P("		// Convert request parameters to message fields")
		g.P("		if err := convertParamsToMessage(request.Params.Arguments, req); err != nil {")
		g.P("			return nil, err")
		g.P("		}")
		g.P("		// Serialize the message to JSON")
		g.P("		jsonBytes, err := protojson.Marshal(req)")
		g.P("		if err != nil {")
		g.P("			return nil, fmt.Errorf(\"failed to serialize message: %v\", err)")
		g.P("		}")
		g.P("		return []mcp.ResourceContents{mcp.TextResourceContents{")
		g.P("			Text: string(jsonBytes),")
		g.P("		}}, nil")
		g.P("	})")
		g.P()

		// Register output message as resource
		g.P("	// Register ", method.Output.GoIdent, " as resource")
		g.P("	s.MCPServer.AddResource(mcp.Resource{")
		g.P("		URI: \"", method.Output.GoIdent, "\",")
		g.P("		Name: \"", method.Output.GoIdent, "\",")
		g.P("		Description: \"Response message for ", method.GoName, " method\",")
		g.P("		MIMEType: \"application/json\",")
		g.P("	}, func(ctx context.Context, request mcp.ReadResourceRequest) ([]mcp.ResourceContents, error) {")
		g.P("		// Create a new instance of the response message")
		g.P("		resp := &", method.Output.GoIdent, "{}")
		g.P("		// Convert request parameters to message fields")
		g.P("		if err := convertParamsToMessage(request.Params.Arguments, resp); err != nil {")
		g.P("			return nil, err")
		g.P("		}")
		g.P("		// Serialize the message to JSON")
		g.P("		jsonBytes, err := protojson.Marshal(resp)")
		g.P("		if err != nil {")
		g.P("			return nil, fmt.Errorf(\"failed to serialize message: %v\", err)")
		g.P("		}")
		g.P("		return []mcp.ResourceContents{mcp.TextResourceContents{")
		g.P("			Text: string(jsonBytes),")
		g.P("		}}, nil")
		g.P("	})")
		g.P()
	}

	g.P("	// Register tools for each method")
	for i, method := range service.Methods {
		if err := generateMethodTool(g, service, method, i); err != nil {
			return err
		}
	}
	g.P("	return s")
	g.P("}")
	g.P()

	// Generate method to start the server
	g.P("// Start starts the MCP server")
	g.P("func (s *", service.GoName, "MCPServerImpl) Start() error {")
	g.P("	return server.ServeStdio(s.MCPServer)")
	g.P("}")
	g.P()

	// Generate helper function to convert parameters to message fields
	g.P("// convertParamsToMessage converts MCP parameters to message fields")
	g.P("func convertParamsToMessage(params map[string]interface{}, msg interface{}) error {")
	g.P("	// Use reflection to set message fields")
	g.P("	val := reflect.ValueOf(msg).Elem()")
	g.P("	typ := val.Type()")
	g.P()
	g.P("	for i := 0; i < val.NumField(); i++ {")
	g.P("		field := val.Field(i)")
	g.P("		fieldType := typ.Field(i)")
	g.P()
	g.P("		// Get field name from protobuf tag")
	g.P("		tag := fieldType.Tag.Get(\"protobuf\")")
	g.P("		if tag == \"\" {")
	g.P("			continue")
	g.P("		}")
	g.P()
	g.P("		// Extract field name from protobuf tag")
	g.P("		parts := strings.Split(tag, \",\")")
	g.P("		if len(parts) < 3 {")
	g.P("			continue")
	g.P("		}")
	g.P("		fieldName := parts[2]")
	g.P()
	g.P("		// Get value from params")
	g.P("		paramVal, ok := params[fieldName]")
	g.P("		if !ok {")
	g.P("			continue")
	g.P("		}")
	g.P()
	g.P("		// Convert and set field value based on type")
	g.P("		switch field.Kind() {")
	g.P("		case reflect.String:")
	g.P("			if strVal, ok := paramVal.(string); ok {")
	g.P("				field.SetString(strVal)")
	g.P("			}")
	g.P("		case reflect.Int32, reflect.Int64:")
	g.P("			if numVal, ok := paramVal.(float64); ok {")
	g.P("				field.SetInt(int64(numVal))")
	g.P("			}")
	g.P("		case reflect.Uint32, reflect.Uint64:")
	g.P("			if numVal, ok := paramVal.(float64); ok {")
	g.P("				field.SetUint(uint64(numVal))")
	g.P("			}")
	g.P("		case reflect.Bool:")
	g.P("			if boolVal, ok := paramVal.(bool); ok {")
	g.P("				field.SetBool(boolVal)")
	g.P("			}")
	g.P("		case reflect.Slice:")
	g.P("			if arrVal, ok := paramVal.([]interface{}); ok {")
	g.P("				slice := reflect.MakeSlice(field.Type(), len(arrVal), len(arrVal))")
	g.P("				for j, v := range arrVal {")
	g.P("					switch field.Type().Elem().Kind() {")
	g.P("					case reflect.String:")
	g.P("						if strVal, ok := v.(string); ok {")
	g.P("							slice.Index(j).SetString(strVal)")
	g.P("						}")
	g.P("					case reflect.Int32, reflect.Int64:")
	g.P("						if numVal, ok := v.(float64); ok {")
	g.P("							slice.Index(j).SetInt(int64(numVal))")
	g.P("						}")
	g.P("					case reflect.Uint32, reflect.Uint64:")
	g.P("						if numVal, ok := v.(float64); ok {")
	g.P("							slice.Index(j).SetUint(uint64(numVal))")
	g.P("						}")
	g.P("					case reflect.Bool:")
	g.P("						if boolVal, ok := v.(bool); ok {")
	g.P("							slice.Index(j).SetBool(boolVal)")
	g.P("						}")
	g.P("					}")
	g.P("				}")
	g.P("				field.Set(slice)")
	g.P("			}")
	g.P("		}")
	g.P("	}")
	g.P()
	g.P("	return nil")
	g.P("}")
	g.P()

	return nil
}

func generateMethodTool(g *protogen.GeneratedFile, service *protogen.Service, method *protogen.Method, index int) error {
	// Check if this is an MCP method by looking for mcp_tool_description
	mcpDescription, ok := proto.GetExtension(method.Desc.Options(), mcp.E_McpToolDescription).(string)
	if !ok || mcpDescription == "" {
		return nil
	}

	// Get MCP method options
	mcpTitle := proto.GetExtension(method.Desc.Options(), mcp.E_McpToolTitle).(string)
	mcpReadOnly := proto.GetExtension(method.Desc.Options(), mcp.E_McpToolReadOnly).(bool)
	mcpDestructive := proto.GetExtension(method.Desc.Options(), mcp.E_McpToolDestructive).(bool)
	mcpIdempotent := proto.GetExtension(method.Desc.Options(), mcp.E_McpToolIdempotent).(bool)
	mcpOpenWorld := proto.GetExtension(method.Desc.Options(), mcp.E_McpToolOpenWorld).(bool)

	// Generate tool creation
	g.P("	// Create tool for ", method.GoName)
	if index == 0 {
		g.P("	tool := mcp.NewTool(\"", method.GoName, "\",")
	} else {
		g.P("	tool = mcp.NewTool(\"", method.GoName, "\",")
	}
	if mcpDescription != "" {
		g.P("		mcp.WithDescription(\"", mcpDescription, "\"),")
	}
	if mcpTitle != "" || mcpReadOnly || mcpDestructive || mcpIdempotent || mcpOpenWorld {
		g.P("		mcp.WithToolAnnotation(mcp.ToolAnnotation{")
		if mcpTitle != "" {
			g.P("			Title:           \"", mcpTitle, "\",")
		}
		g.P("			ReadOnlyHint:    ", mcpReadOnly, ",")
		g.P("			DestructiveHint: ", mcpDestructive, ",")
		g.P("			IdempotentHint:  ", mcpIdempotent, ",")
		g.P("			OpenWorldHint:   ", mcpOpenWorld, ",")
		g.P("		}),")
	}

	// Add parameters for each field in the input message
	for _, field := range method.Input.Fields {
		fieldDesc := proto.GetExtension(field.Desc.Options(), mcp.E_McpFieldDescription).(string)
		isRequired := proto.GetExtension(field.Desc.Options(), mcp.E_McpRequired).(bool)
		validationPattern := proto.GetExtension(field.Desc.Options(), mcp.E_McpValidationPattern).(string)

		// Determine parameter type based on field type
		switch field.Desc.Kind() {
		case protoreflect.StringKind:
			if field.Desc.IsList() {
				g.P("		mcp.WithArray(\"", field.GoName, "\",")
			} else {
				g.P("		mcp.WithString(\"", field.GoName, "\",")
			}
			if isRequired {
				g.P("			mcp.Required(),")
			}
			if fieldDesc != "" {
				g.P("			mcp.Description(\"", fieldDesc, "\"),")
			}
			if validationPattern != "" {
				g.P("			mcp.Pattern(\"", validationPattern, "\",),")
			}
			g.P("		),")
		case protoreflect.BytesKind:
			if field.Desc.IsList() {
				g.P("		mcp.WithArray(\"", field.GoName, "\",")
			} else {
				g.P("		mcp.WithString(\"", field.GoName, "\",")
			}
			if isRequired {
				g.P("			mcp.Required(),")
			}
			if fieldDesc != "" {
				g.P("			mcp.Description(\"", fieldDesc, "\"),")
			}
			g.P("		),")
		case protoreflect.Int32Kind, protoreflect.Int64Kind,
			protoreflect.Uint32Kind, protoreflect.Uint64Kind:
			if field.Desc.IsList() {
				g.P("		mcp.WithArray(\"", field.GoName, "\",")
			} else {
				g.P("		mcp.WithNumber(\"", field.GoName, "\",")
			}
			if isRequired {
				g.P("			mcp.Required(),")
			}
			if fieldDesc != "" {
				g.P("			mcp.Description(\"", fieldDesc, "\"),")
			}
			g.P("		),")
		case protoreflect.BoolKind:
			if field.Desc.IsList() {
				g.P("		mcp.WithArray(\"", field.GoName, "\",")
			} else {
				g.P("		mcp.WithBoolean(\"", field.GoName, "\",")
			}
			if isRequired {
				g.P("			mcp.Required(),")
			}
			if fieldDesc != "" {
				g.P("			mcp.Description(\"", fieldDesc, "\"),")
			}
			g.P("		),")
		case protoreflect.MessageKind:
			if field.Desc.IsMap() {
				g.P("		mcp.WithObject(\"", field.GoName, "\",")
				if isRequired {
					g.P("			mcp.Required(),")
				}
				if fieldDesc != "" {
					g.P("			mcp.Description(\"", fieldDesc, "\"),")
				}
				g.P("		),")
			}
		}
	}
	g.P("	)")

	// Generate handler function
	g.P()
	g.P("	// Add tool handler")
	g.P("	s.MCPServer.AddTool(tool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {")
	g.P("		// Create input message")
	g.P("		req := &", method.Input.GoIdent, "{}")

	// Parse parameters from request
	for _, field := range method.Input.Fields {
		g.P("		if val, ok := request.Params.Arguments[\"", field.GoName, "\"]; ok {")
		switch field.Desc.Kind() {
		case protoreflect.StringKind:
			if field.Desc.IsList() {
				g.P("			if arrVal, ok := val.([]interface{}); ok {")
				g.P("				req.", field.GoName, " = make([]string, len(arrVal))")
				g.P("				for i, v := range arrVal {")
				g.P("					if strVal, ok := v.(string); ok {")
				g.P("						req.", field.GoName, "[i] = strVal")
				g.P("					} else {")
				g.P("						return nil, fmt.Errorf(\"", field.GoName, " must be an array of strings\")")
				g.P("					}")
				g.P("				}")
				g.P("			} else {")
				g.P("				return nil, fmt.Errorf(\"", field.GoName, " must be an array of strings\")")
				g.P("			}")
			} else {
				g.P("			if strVal, ok := val.(string); ok {")
				g.P("				req.", field.GoName, " = strVal")
				g.P("			} else {")
				g.P("				return nil, fmt.Errorf(\"", field.GoName, " must be a string\")")
				g.P("			}")
			}
		case protoreflect.BytesKind:
			if field.Desc.IsList() {
				g.P("			if arrVal, ok := val.([]interface{}); ok {")
				g.P("				req.", field.GoName, " = make([][]byte, len(arrVal))")
				g.P("				for i, v := range arrVal {")
				g.P("					if strVal, ok := v.(string); ok {")
				g.P("						req.", field.GoName, "[i] = []byte(strVal)")
				g.P("					} else {")
				g.P("						return nil, fmt.Errorf(\"", field.GoName, " must be an array of strings\")")
				g.P("					}")
				g.P("				}")
				g.P("			} else {")
				g.P("				return nil, fmt.Errorf(\"", field.GoName, " must be an array of strings\")")
				g.P("			}")
			} else {
				g.P("			if strVal, ok := val.(string); ok {")
				g.P("				req.", field.GoName, " = []byte(strVal)")
				g.P("			} else {")
				g.P("				return nil, fmt.Errorf(\"", field.GoName, " must be a string\")")
				g.P("			}")
			}
		case protoreflect.Int32Kind, protoreflect.Int64Kind,
			protoreflect.Uint32Kind, protoreflect.Uint64Kind:
			if field.Desc.IsList() {
				g.P("			if arrVal, ok := val.([]interface{}); ok {")
				g.P("				req.", field.GoName, " = make([]", getTypeName(field.Desc.Kind()), ", len(arrVal))")
				g.P("				for i, v := range arrVal {")
				g.P("					if numVal, ok := v.(float64); ok {")
				g.P("						req.", field.GoName, "[i] = ", getTypeConversion(field.Desc.Kind(), "numVal"))
				g.P("					} else {")
				g.P("						return nil, fmt.Errorf(\"", field.GoName, " must be an array of numbers\")")
				g.P("					}")
				g.P("				}")
				g.P("			} else {")
				g.P("				return nil, fmt.Errorf(\"", field.GoName, " must be an array of numbers\")")
				g.P("			}")
			} else {
				g.P("			if numVal, ok := val.(float64); ok {")
				g.P("				req.", field.GoName, " = ", getTypeConversion(field.Desc.Kind(), "numVal"))
				g.P("			} else {")
				g.P("				return nil, fmt.Errorf(\"", field.GoName, " must be a number\")")
				g.P("			}")
			}
		case protoreflect.BoolKind:
			if field.Desc.IsList() {
				g.P("			if arrVal, ok := val.([]interface{}); ok {")
				g.P("				req.", field.GoName, " = make([]bool, len(arrVal))")
				g.P("				for i, v := range arrVal {")
				g.P("					if boolVal, ok := v.(bool); ok {")
				g.P("						req.", field.GoName, "[i] = boolVal")
				g.P("					} else {")
				g.P("						return nil, fmt.Errorf(\"", field.GoName, " must be an array of booleans\")")
				g.P("					}")
				g.P("				}")
				g.P("			} else {")
				g.P("				return nil, fmt.Errorf(\"", field.GoName, " must be an array of booleans\")")
				g.P("			}")
			} else {
				g.P("			if boolVal, ok := val.(bool); ok {")
				g.P("				req.", field.GoName, " = boolVal")
				g.P("			} else {")
				g.P("				return nil, fmt.Errorf(\"", field.GoName, " must be a boolean\")")
				g.P("			}")
			}
		case protoreflect.MessageKind:
			if field.Desc.IsMap() {
				g.P("			if mapVal, ok := val.(map[string]interface{}); ok {")
				g.P("				req.", field.GoName, " = make(map[string]", getMapValueType(field.Desc.MapValue().Kind()), ")")
				g.P("				for k, v := range mapVal {")
				g.P("					", getMapValueConversion(field.Desc.MapValue().Kind(), "v", "req."+field.GoName+"[k]"))
				g.P("				}")
				g.P("			} else {")
				g.P("				return nil, fmt.Errorf(\"", field.GoName, " must be a map\")")
				g.P("			}")
			}
		}
		g.P("		}")
	}

	// Call the service method
	g.P()
	g.P("		// Call the service method")
	g.P("		resp, err := s.server.", method.GoName, "(ctx, req)")
	g.P("		if err != nil {")
	g.P("			return nil, err")
	g.P("		}")
	g.P()
	g.P("		// Convert response to MCP result")
	g.P("		return mcp.NewToolResultText(fmt.Sprintf(\"%+v\", resp)), nil")
	g.P("	})")
	g.P()

	return nil
}

func getTypeConversion(kind protoreflect.Kind, value string) string {
	switch kind {
	case protoreflect.Int32Kind:
		return "int32(" + value + ")"
	case protoreflect.Int64Kind:
		return "int64(" + value + ")"
	case protoreflect.Uint32Kind:
		return "uint32(" + value + ")"
	case protoreflect.Uint64Kind:
		return "uint64(" + value + ")"
	default:
		return value
	}
}

func getTypeName(kind protoreflect.Kind) string {
	switch kind {
	case protoreflect.Int32Kind:
		return "int32"
	case protoreflect.Int64Kind:
		return "int64"
	case protoreflect.Uint32Kind:
		return "uint32"
	case protoreflect.Uint64Kind:
		return "uint64"
	default:
		return "int32"
	}
}

func getMapValueType(kind protoreflect.Kind) string {
	switch kind {
	case protoreflect.StringKind:
		return "string"
	case protoreflect.Int32Kind:
		return "int32"
	case protoreflect.Int64Kind:
		return "int64"
	case protoreflect.Uint32Kind:
		return "uint32"
	case protoreflect.Uint64Kind:
		return "uint64"
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.BytesKind:
		return "[]byte"
	default:
		return "string"
	}
}

func getMapValueConversion(kind protoreflect.Kind, valueVar, targetVar string) string {
	switch kind {
	case protoreflect.StringKind:
		return fmt.Sprintf("if strVal, ok := %s.(string); ok {\n\t\t\t\t%s = strVal\n\t\t\t} else {\n\t\t\t\treturn nil, fmt.Errorf(\"map value must be a string\")\n\t\t\t}", valueVar, targetVar)
	case protoreflect.Int32Kind:
		return fmt.Sprintf("if numVal, ok := %s.(float64); ok {\n\t\t\t\t%s = int32(numVal)\n\t\t\t} else {\n\t\t\t\treturn nil, fmt.Errorf(\"map value must be a number\")\n\t\t\t}", valueVar, targetVar)
	case protoreflect.Int64Kind:
		return fmt.Sprintf("if numVal, ok := %s.(float64); ok {\n\t\t\t\t%s = int64(numVal)\n\t\t\t} else {\n\t\t\t\treturn nil, fmt.Errorf(\"map value must be a number\")\n\t\t\t}", valueVar, targetVar)
	case protoreflect.Uint32Kind:
		return fmt.Sprintf("if numVal, ok := %s.(float64); ok {\n\t\t\t\t%s = uint32(numVal)\n\t\t\t} else {\n\t\t\t\treturn nil, fmt.Errorf(\"map value must be a number\")\n\t\t\t}", valueVar, targetVar)
	case protoreflect.Uint64Kind:
		return fmt.Sprintf("if numVal, ok := %s.(float64); ok {\n\t\t\t\t%s = uint64(numVal)\n\t\t\t} else {\n\t\t\t\treturn nil, fmt.Errorf(\"map value must be a number\")\n\t\t\t}", valueVar, targetVar)
	case protoreflect.BoolKind:
		return fmt.Sprintf("if boolVal, ok := %s.(bool); ok {\n\t\t\t\t%s = boolVal\n\t\t\t} else {\n\t\t\t\treturn nil, fmt.Errorf(\"map value must be a boolean\")\n\t\t\t}", valueVar, targetVar)
	case protoreflect.BytesKind:
		return fmt.Sprintf("if strVal, ok := %s.(string); ok {\n\t\t\t\t%s = []byte(strVal)\n\t\t\t} else {\n\t\t\t\treturn nil, fmt.Errorf(\"map value must be a string\")\n\t\t\t}", valueVar, targetVar)
	default:
		return fmt.Sprintf("if strVal, ok := %s.(string); ok {\n\t\t\t\t%s = strVal\n\t\t\t} else {\n\t\t\t\treturn nil, fmt.Errorf(\"map value must be a string\")\n\t\t\t}", valueVar, targetVar)
	}
}
