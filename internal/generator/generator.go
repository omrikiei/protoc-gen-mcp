package generator

import (
	"github.com/omrikiei/protoc-gen-mcp/internal/protogen/mcp"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

// GenerateFile generates the MCP server, client, and mock server code for a proto file.
func GenerateFile(gen *protogen.Plugin, file *protogen.File) error {
	if len(file.Services) == 0 {
		return nil
	}

	// Generate the MCP server package
	mcpFilename := file.GeneratedFilenamePrefix + "_mcp/mcp.pb.go"
	mcpG := gen.NewGeneratedFile(mcpFilename, protogen.GoImportPath(file.GoImportPath.String()+"_mcp"))

	// Generate header for MCP package
	mcpG.P("// Code generated by protoc-gen-mcp. DO NOT EDIT.")
	mcpG.P("// source: ", file.Desc.Path())
	mcpG.P()
	mcpG.P("package ", file.GoPackageName+"_mcp")
	mcpG.P()

	// Generate imports for MCP package
	mcpG.P("import (")
	mcpG.P(`	"context"`)
	mcpG.P(`	"encoding/json"`)
	mcpG.P(`	"fmt"`)
	mcpG.P(`	"io"`)
	mcpG.P(`	"net/http"`)
	mcpG.P(`	"strings"`)
	mcpG.P()
	mcpG.P(`	"google.golang.org/grpc"`)
	mcpG.P()
	mcpG.P("	", file.GoImportPath)
	mcpG.P(")")
	mcpG.P()

	// Generate utility functions for path and query parameter handling
	mcpG.P("// ParsePathParams extracts path parameters from the request URL.")
	mcpG.P("func ParsePathParams(pattern, path string) (map[string]string, error) {")
	mcpG.P("	patternParts := strings.Split(pattern, \"/\")")
	mcpG.P("	pathParts := strings.Split(path, \"/\")")
	mcpG.P()

	mcpG.P("	if len(patternParts) != len(pathParts) {")
	mcpG.P("		return nil, fmt.Errorf(\"path length mismatch\")")
	mcpG.P("	}")
	mcpG.P()

	mcpG.P("	params := make(map[string]string)")
	mcpG.P("	for i, part := range patternParts {")
	mcpG.P("		if strings.HasPrefix(part, \"{\") && strings.HasSuffix(part, \"}\") {")
	mcpG.P("			paramName := part[1 : len(part)-1]")
	mcpG.P("			params[paramName] = pathParts[i]")
	mcpG.P("		}")
	mcpG.P("	}")
	mcpG.P("	return params, nil")
	mcpG.P("}")
	mcpG.P()

	mcpG.P("// ApplyPathParams sets path parameters in the request message.")
	mcpG.P("func ApplyPathParams(req interface{}, params map[string]string) error {")
	mcpG.P("	// This is a simplified implementation that assumes the request struct")
	mcpG.P("	// has fields matching the parameter names.")
	mcpG.P("	// In a real implementation, you would use reflection to set the fields.")
	mcpG.P("	return nil")
	mcpG.P("}")
	mcpG.P()

	mcpG.P("// ApplyQueryParams sets query parameters in the request message.")
	mcpG.P("func ApplyQueryParams(req interface{}, params map[string][]string) error {")
	mcpG.P("	// This is a simplified implementation that assumes the request struct")
	mcpG.P("	// has fields matching the parameter names.")
	mcpG.P("	// In a real implementation, you would use reflection to set the fields.")
	mcpG.P("	return nil")
	mcpG.P("}")
	mcpG.P()

	// Generate code for each service
	for _, service := range file.Services {
		if err := generateService(mcpG, service, file); err != nil {
			return err
		}
	}

	return nil
}

func generateService(mcpG *protogen.GeneratedFile, service *protogen.Service, file *protogen.File) error {
	// Check if this is an MCP service
	isMCPService := proto.GetExtension(service.Desc.Options(), mcp.E_McpService).(bool)
	if !isMCPService {
		return nil
	}

	// Get MCP service options
	mcpVersion := proto.GetExtension(service.Desc.Options(), mcp.E_McpVersion).(string)
	mcpType := proto.GetExtension(service.Desc.Options(), mcp.E_McpType).(string)

	// Generate server interface
	mcpG.P("// ", service.GoName, "Server is the MCP server API for ", service.GoName, " service.")
	mcpG.P("type ", service.GoName, "Server interface {")
	for _, method := range service.Methods {
		mcpG.P(method.GoName, "(context.Context, *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error)")
	}
	mcpG.P("}")
	mcpG.P()

	// Generate MCP server implementation
	mcpG.P("// ", service.GoName, "MCPServer implements the MCP server for ", service.GoName, " service.")
	mcpG.P("type ", service.GoName, "MCPServer struct {")
	mcpG.P("	server ", service.GoName, "Server")
	mcpG.P("	version string")
	mcpG.P("	serviceType string")
	mcpG.P("}")
	mcpG.P()

	// Generate MCP server constructor
	mcpG.P("// New", service.GoName, "MCPServer creates a new MCP server for ", service.GoName, " service.")
	mcpG.P("func New", service.GoName, "MCPServer(server ", service.GoName, "Server) *", service.GoName, "MCPServer {")
	mcpG.P("	return &", service.GoName, "MCPServer{")
	mcpG.P("		server: server,")
	mcpG.P("		version: \"", mcpVersion, "\",")
	mcpG.P("		serviceType: \"", mcpType, "\",")
	mcpG.P("	}")
	mcpG.P("}")
	mcpG.P()

	// Generate MCP server methods
	for _, method := range service.Methods {
		if err := generateMCPServerMethod(mcpG, service, method); err != nil {
			return err
		}
	}

	// Generate HTTP handler registration
	mcpG.P("// RegisterHTTPHandlers registers the HTTP handlers for the MCP server.")
	mcpG.P("func (s *", service.GoName, "MCPServer) RegisterHTTPHandlers(mux *http.ServeMux) {")
	for _, method := range service.Methods {
		isMCPMethod := proto.GetExtension(method.Desc.Options(), mcp.E_McpMethod).(bool)
		if !isMCPMethod {
			continue
		}
		path := proto.GetExtension(method.Desc.Options(), mcp.E_McpPath).(string)
		mcpG.P("	mux.HandleFunc(\"", path, "\", s.Handle", method.GoName, ")")
	}
	mcpG.P("}")
	mcpG.P()

	// Generate client interface
	mcpG.P("// ", service.GoName, "Client is the MCP client API for ", service.GoName, " service.")
	mcpG.P("type ", service.GoName, "Client interface {")
	for _, method := range service.Methods {
		mcpG.P(method.GoName, "(context.Context, *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error)")
	}
	mcpG.P("}")
	mcpG.P()

	// Generate MCP client implementation
	mcpG.P("// ", service.GoName, "MCPClient implements the MCP client for ", service.GoName, " service.")
	mcpG.P("type ", service.GoName, "MCPClient struct {")
	mcpG.P("	client *http.Client")
	mcpG.P("	baseURL string")
	mcpG.P("	version string")
	mcpG.P("	serviceType string")
	mcpG.P("}")
	mcpG.P()

	// Generate MCP client constructor
	mcpG.P("// New", service.GoName, "MCPClient creates a new MCP client for ", service.GoName, " service.")
	mcpG.P("func New", service.GoName, "MCPClient(baseURL string) *", service.GoName, "MCPClient {")
	mcpG.P("	return &", service.GoName, "MCPClient{")
	mcpG.P("		client: &http.Client{},")
	mcpG.P("		baseURL: strings.TrimSuffix(baseURL, \"/\"),")
	mcpG.P("		version: \"", mcpVersion, "\",")
	mcpG.P("		serviceType: \"", mcpType, "\",")
	mcpG.P("	}")
	mcpG.P("}")
	mcpG.P()

	// Generate MCP client methods
	for _, method := range service.Methods {
		if err := generateMCPClientMethod(mcpG, service, method); err != nil {
			return err
		}
	}

	// Generate GRPC server implementation
	mcpG.P("// ", service.GoName, "GRPCServer implements the MCP server using GRPC client.")
	mcpG.P("type ", service.GoName, "GRPCServer struct {")
	mcpG.P("	client ", file.GoPackageName, ".", service.GoName, "Client")
	mcpG.P("}")
	mcpG.P()

	mcpG.P("// New", service.GoName, "GRPCServer creates a new MCP server that uses GRPC client.")
	mcpG.P("func New", service.GoName, "GRPCServer(conn *grpc.ClientConn) *", service.GoName, "GRPCServer {")
	mcpG.P("	return &", service.GoName, "GRPCServer{")
	mcpG.P("		client: ", file.GoPackageName, ".New", service.GoName, "Client(conn),")
	mcpG.P("	}")
	mcpG.P("}")
	mcpG.P()

	// Generate GRPC server methods
	for _, method := range service.Methods {
		mcpG.P("// ", method.GoName, " implements the MCP server method using GRPC client.")
		mcpG.P("func (s *", service.GoName, "GRPCServer) ", method.GoName, "(ctx context.Context, req *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error) {")
		mcpG.P("	return s.client.", method.GoName, "(ctx, req)")
		mcpG.P("}")
		mcpG.P()
	}

	return nil
}

func generateMCPServerMethod(g *protogen.GeneratedFile, service *protogen.Service, method *protogen.Method) error {
	// Check if this is an MCP method
	isMCPMethod := proto.GetExtension(method.Desc.Options(), mcp.E_McpMethod).(bool)
	if !isMCPMethod {
		return nil
	}

	// Get MCP method options
	httpMethod := proto.GetExtension(method.Desc.Options(), mcp.E_McpHttpMethod).(string)
	path := proto.GetExtension(method.Desc.Options(), mcp.E_McpPath).(string)

	g.P("// Handle", method.GoName, " handles the MCP request for ", method.GoName, " method.")
	g.P("func (s *", service.GoName, "MCPServer) Handle", method.GoName, "(w http.ResponseWriter, r *http.Request) {")
	g.P("	if r.Method != \"", httpMethod, "\" {")
	g.P("		http.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)")
	g.P("		return")
	g.P("	}")
	g.P()

	// Parse path parameters
	g.P("	pathParams, err := ParsePathParams(\"", path, "\", r.URL.Path)")
	g.P("	if err != nil {")
	g.P("		http.Error(w, \"Invalid path parameters\", http.StatusBadRequest)")
	g.P("		return")
	g.P("	}")
	g.P()

	// Parse query parameters
	g.P("	queryParams := r.URL.Query()")
	g.P()

	// Parse request body
	g.P("	body, err := io.ReadAll(r.Body)")
	g.P("	if err != nil {")
	g.P("		http.Error(w, \"Failed to read request body\", http.StatusBadRequest)")
	g.P("		return")
	g.P("	}")
	g.P()

	// Create request message
	g.P("	req := &", method.Input.GoIdent, "{}")
	g.P("	if err := json.Unmarshal(body, req); err != nil {")
	g.P("		http.Error(w, \"Failed to parse request body\", http.StatusBadRequest)")
	g.P("		return")
	g.P("	}")
	g.P()

	// Apply path parameters to request
	g.P("	if err := ApplyPathParams(req, pathParams); err != nil {")
	g.P("		http.Error(w, \"Failed to apply path parameters\", http.StatusBadRequest)")
	g.P("		return")
	g.P("	}")
	g.P()

	// Apply query parameters to request
	g.P("	if err := ApplyQueryParams(req, queryParams); err != nil {")
	g.P("		http.Error(w, \"Failed to apply query parameters\", http.StatusBadRequest)")
	g.P("		return")
	g.P("	}")
	g.P()

	// Call the service method
	g.P("	resp, err := s.server.", method.GoName, "(r.Context(), req)")
	g.P("	if err != nil {")
	g.P("		http.Error(w, err.Error(), http.StatusInternalServerError)")
	g.P("		return")
	g.P("	}")
	g.P()

	// Write response
	g.P("	w.Header().Set(\"Content-Type\", \"application/json\")")
	g.P("	if err := json.NewEncoder(w).Encode(resp); err != nil {")
	g.P("		http.Error(w, \"Failed to encode response\", http.StatusInternalServerError)")
	g.P("		return")
	g.P("	}")
	g.P("}")
	g.P()

	return nil
}

func generateMCPClientMethod(g *protogen.GeneratedFile, service *protogen.Service, method *protogen.Method) error {
	// Check if this is an MCP method
	isMCPMethod := proto.GetExtension(method.Desc.Options(), mcp.E_McpMethod).(bool)
	if !isMCPMethod {
		return nil
	}

	// Get MCP method options
	httpMethod := proto.GetExtension(method.Desc.Options(), mcp.E_McpHttpMethod).(string)
	path := proto.GetExtension(method.Desc.Options(), mcp.E_McpPath).(string)

	g.P("// ", method.GoName, " sends a request to the ", method.GoName, " method.")
	g.P("func (c *", service.GoName, "MCPClient) ", method.GoName, "(ctx context.Context, req *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error) {")
	g.P("	// Create request body")
	g.P("	body, err := json.Marshal(req)")
	g.P("	if err != nil {")
	g.P("		return nil, fmt.Errorf(\"failed to marshal request: %w\", err)")
	g.P("	}")
	g.P()

	// Create HTTP request
	g.P("	url := fmt.Sprintf(\"%s%s\", c.baseURL, \"", path, "\")")
	g.P("	httpReq, err := http.NewRequestWithContext(ctx, \"", httpMethod, "\", url, strings.NewReader(string(body)))")
	g.P("	if err != nil {")
	g.P("		return nil, fmt.Errorf(\"failed to create request: %w\", err)")
	g.P("	}")
	g.P()

	// Set headers
	g.P("	httpReq.Header.Set(\"Content-Type\", \"application/json\")")
	g.P("	httpReq.Header.Set(\"X-MCP-Version\", c.version)")
	g.P("	httpReq.Header.Set(\"X-MCP-Type\", c.serviceType)")
	g.P()

	// Send request
	g.P("	resp, err := c.client.Do(httpReq)")
	g.P("	if err != nil {")
	g.P("		return nil, fmt.Errorf(\"failed to send request: %w\", err)")
	g.P("	}")
	g.P("	defer resp.Body.Close()")
	g.P()

	// Read response body
	g.P("	respBody, err := io.ReadAll(resp.Body)")
	g.P("	if err != nil {")
	g.P("		return nil, fmt.Errorf(\"failed to read response: %w\", err)")
	g.P("	}")
	g.P()

	// Check status code
	g.P("	if resp.StatusCode != http.StatusOK {")
	g.P("		return nil, fmt.Errorf(\"unexpected status code: %d, body: %s\", resp.StatusCode, string(respBody))")
	g.P("	}")
	g.P()

	// Parse response
	g.P("	var result ", method.Output.GoIdent)
	g.P("	if err := json.Unmarshal(respBody, &result); err != nil {")
	g.P("		return nil, fmt.Errorf(\"failed to parse response: %w\", err)")
	g.P("	}")
	g.P()

	g.P("	return &result, nil")
	g.P("}")
	g.P()

	return nil
}
