package generator

import (
	"github.com/omrikiei/protoc-gen-mcp/internal/protogen/mcp"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

// GenerateFile generates the MCP server, client, and mock server code for a proto file.
func GenerateFile(gen *protogen.Plugin, file *protogen.File) error {
	if len(file.Services) == 0 {
		return nil
	}

	filename := file.GeneratedFilenamePrefix + "_mcp.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	// Generate header
	g.P("// Code generated by protoc-gen-mcp. DO NOT EDIT.")
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	// Generate imports
	g.P("import (")
	g.P(`	"context"`)
	g.P(`	"encoding/json"`)
	g.P(`	"fmt"`)
	g.P(`	"io"`)
	g.P(`	"net/http"`)
	g.P(`	"strings"`)
	g.P()
	g.P(`	"github.com/omrikiei/protoc-gen-mcp/internal/protogen/mcp"`)
	g.P(")")
	g.P()

	// Generate code for each service
	for _, service := range file.Services {
		if err := generateService(g, service); err != nil {
			return err
		}
	}

	return nil
}

func generateService(g *protogen.GeneratedFile, service *protogen.Service) error {
	// Check if this is an MCP service
	isMCPService := proto.GetExtension(service.Desc.Options(), mcp.E_McpService).(bool)
	if !isMCPService {
		return nil
	}

	// Get MCP service options
	mcpVersion := proto.GetExtension(service.Desc.Options(), mcp.E_McpVersion).(string)
	mcpType := proto.GetExtension(service.Desc.Options(), mcp.E_McpType).(string)

	// Generate server interface
	g.P("// ", service.GoName, "Server is the MCP server API for ", service.GoName, " service.")
	g.P("type ", service.GoName, "Server interface {")
	for _, method := range service.Methods {
		g.P(method.GoName, "(context.Context, *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error)")
	}
	g.P("}")
	g.P()

	// Generate MCP server implementation
	g.P("// ", service.GoName, "MCPServer implements the MCP server for ", service.GoName, " service.")
	g.P("type ", service.GoName, "MCPServer struct {")
	g.P("	server ", service.GoName, "Server")
	g.P("	version string")
	g.P("	serviceType string")
	g.P("}")
	g.P()

	// Generate MCP server constructor
	g.P("// New", service.GoName, "MCPServer creates a new MCP server for ", service.GoName, " service.")
	g.P("func New", service.GoName, "MCPServer(server ", service.GoName, "Server) *", service.GoName, "MCPServer {")
	g.P("	return &", service.GoName, "MCPServer{")
	g.P("		server: server,")
	g.P("		version: \"", mcpVersion, "\",")
	g.P("		serviceType: \"", mcpType, "\",")
	g.P("	}")
	g.P("}")
	g.P()

	// Generate MCP server methods
	for _, method := range service.Methods {
		if err := generateMCPServerMethod(g, service, method); err != nil {
			return err
		}
	}

	// Generate client interface
	g.P("// ", service.GoName, "Client is the MCP client API for ", service.GoName, " service.")
	g.P("type ", service.GoName, "Client interface {")
	for _, method := range service.Methods {
		g.P(method.GoName, "(context.Context, *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error)")
	}
	g.P("}")
	g.P()

	// Generate MCP client implementation
	g.P("// ", service.GoName, "MCPClient implements the MCP client for ", service.GoName, " service.")
	g.P("type ", service.GoName, "MCPClient struct {")
	g.P("	client *http.Client")
	g.P("	baseURL string")
	g.P("	version string")
	g.P("	serviceType string")
	g.P("}")
	g.P()

	// Generate MCP client constructor
	g.P("// New", service.GoName, "MCPClient creates a new MCP client for ", service.GoName, " service.")
	g.P("func New", service.GoName, "MCPClient(baseURL string) *", service.GoName, "MCPClient {")
	g.P("	return &", service.GoName, "MCPClient{")
	g.P("		client: &http.Client{},")
	g.P("		baseURL: strings.TrimSuffix(baseURL, \"/\"),")
	g.P("		version: \"", mcpVersion, "\",")
	g.P("		serviceType: \"", mcpType, "\",")
	g.P("	}")
	g.P("}")
	g.P()

	// Generate MCP client methods
	for _, method := range service.Methods {
		if err := generateMCPClientMethod(g, service, method); err != nil {
			return err
		}
	}

	return nil
}

func generateMCPServerMethod(g *protogen.GeneratedFile, service *protogen.Service, method *protogen.Method) error {
	// Check if this is an MCP method
	isMCPMethod := proto.GetExtension(method.Desc.Options(), mcp.E_McpMethod).(bool)
	if !isMCPMethod {
		return nil
	}

	// Get MCP method options
	httpMethod := proto.GetExtension(method.Desc.Options(), mcp.E_McpHttpMethod).(string)
	path := proto.GetExtension(method.Desc.Options(), mcp.E_McpPath).(string)

	g.P("// Handle", method.GoName, " handles the MCP request for ", method.GoName, " method.")
	g.P("func (s *", service.GoName, "MCPServer) Handle", method.GoName, "(w http.ResponseWriter, r *http.Request) {")
	g.P("	if r.Method != \"", httpMethod, "\" {")
	g.P("		http.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)")
	g.P("		return")
	g.P("	}")
	g.P()
	g.P("	// Parse path parameters")
	g.P("	pathParams, err := ParsePathParams(\"", path, "\", r.URL.Path)")
	g.P("	if err != nil {")
	g.P("		http.Error(w, \"Invalid path parameters\", http.StatusBadRequest)")
	g.P("		return")
	g.P("	}")
	g.P()
	g.P("	// Parse query parameters")
	g.P("	queryParams := r.URL.Query()")
	g.P()
	g.P("	// Parse request body")
	g.P("	body, err := io.ReadAll(r.Body)")
	g.P("	if err != nil {")
	g.P("		http.Error(w, \"Failed to read request body\", http.StatusBadRequest)")
	g.P("		return")
	g.P("	}")
	g.P()
	g.P("	// Create request message")
	g.P("	req := &", method.Input.GoIdent, "{}")
	g.P("	if err := json.Unmarshal(body, req); err != nil {")
	g.P("		http.Error(w, \"Failed to parse request body\", http.StatusBadRequest)")
	g.P("		return")
	g.P("	}")
	g.P()
	g.P("	// Apply path parameters to request")
	g.P("	if err := ApplyPathParams(req, pathParams); err != nil {")
	g.P("		http.Error(w, \"Failed to apply path parameters\", http.StatusBadRequest)")
	g.P("		return")
	g.P("	}")
	g.P()
	g.P("	// Apply query parameters to request")
	g.P("	if err := ApplyQueryParams(req, queryParams); err != nil {")
	g.P("		http.Error(w, \"Failed to apply query parameters\", http.StatusBadRequest)")
	g.P("		return")
	g.P("	}")
	g.P()
	g.P("	// Call the service method")
	g.P("	resp, err := s.server.", method.GoName, "(r.Context(), req)")
	g.P("	if err != nil {")
	g.P("		http.Error(w, err.Error(), http.StatusInternalServerError)")
	g.P("		return")
	g.P("	}")
	g.P()
	g.P("	// Write response")
	g.P("	w.Header().Set(\"Content-Type\", \"application/json\")")
	g.P("	if err := json.NewEncoder(w).Encode(resp); err != nil {")
	g.P("		http.Error(w, \"Failed to encode response\", http.StatusInternalServerError)")
	g.P("		return")
	g.P("	}")
	g.P("}")
	g.P()

	return nil
}

func generateMCPClientMethod(g *protogen.GeneratedFile, service *protogen.Service, method *protogen.Method) error {
	// Check if this is an MCP method
	isMCPMethod := proto.GetExtension(method.Desc.Options(), mcp.E_McpMethod).(bool)
	if !isMCPMethod {
		return nil
	}

	// Get MCP method options
	httpMethod := proto.GetExtension(method.Desc.Options(), mcp.E_McpHttpMethod).(string)
	path := proto.GetExtension(method.Desc.Options(), mcp.E_McpPath).(string)

	g.P("// ", method.GoName, " sends a request to the ", method.GoName, " method.")
	g.P("func (c *", service.GoName, "MCPClient) ", method.GoName, "(ctx context.Context, req *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error) {")
	g.P("	// Create request body")
	g.P("	body, err := json.Marshal(req)")
	g.P("	if err != nil {")
	g.P("		return nil, fmt.Errorf(\"failed to marshal request: %w\", err)")
	g.P("	}")
	g.P()
	g.P("	// Create HTTP request")
	g.P("	url := fmt.Sprintf(\"%s%s\", c.baseURL, \"", path, "\")")
	g.P("	httpReq, err := http.NewRequestWithContext(ctx, \"", httpMethod, "\", url, strings.NewReader(string(body)))")
	g.P("	if err != nil {")
	g.P("		return nil, fmt.Errorf(\"failed to create request: %w\", err)")
	g.P("	}")
	g.P()
	g.P("	// Set headers")
	g.P("	httpReq.Header.Set(\"Content-Type\", \"application/json\")")
	g.P("	httpReq.Header.Set(\"X-MCP-Version\", c.version)")
	g.P("	httpReq.Header.Set(\"X-MCP-Type\", c.serviceType)")
	g.P()
	g.P("	// Send request")
	g.P("	resp, err := c.client.Do(httpReq)")
	g.P("	if err != nil {")
	g.P("		return nil, fmt.Errorf(\"failed to send request: %w\", err)")
	g.P("	}")
	g.P("	defer resp.Body.Close()")
	g.P()
	g.P("	// Read response body")
	g.P("	respBody, err := io.ReadAll(resp.Body)")
	g.P("	if err != nil {")
	g.P("		return nil, fmt.Errorf(\"failed to read response: %w\", err)")
	g.P("	}")
	g.P()
	g.P("	// Check status code")
	g.P("	if resp.StatusCode != http.StatusOK {")
	g.P("		return nil, fmt.Errorf(\"unexpected status code: %d, body: %s\", resp.StatusCode, string(respBody))")
	g.P("	}")
	g.P()
	g.P("	// Parse response")
	g.P("	var result ", method.Output.GoIdent)
	g.P("	if err := json.Unmarshal(respBody, &result); err != nil {")
	g.P("		return nil, fmt.Errorf(\"failed to parse response: %w\", err)")
	g.P("	}")
	g.P()
	g.P("	return &result, nil")
	g.P("}")
	g.P()

	return nil
}
